import { v4 as uuidv4 } from 'uuid';
import {
  ActionMap,
  AccessorTile,
  ActionTile,
  MemoryTile,
  Tile,
  TileType,
  Output,
  AccessorType,
  ModelAccessorTile,
  ModelAccessOperation,
  DataInAccessorTile,
  ActionDataSchema,
  OutputCompatiblePaths,
  MemoryType,
  ModelMemoryTile,
  InternalMemoryTile,
} from './types/actionMap';
import actionMapSchema from './schema/actionMap.schema';
import { Model } from '../model/types/model';
import { ComplexDataType, DataSchema, SpecialDataType } from '../dataSchema/types/dataSchema';
import { DataSchemaHandler } from '../dataSchema/dataSchema';
import { accessorTileSchema, actionTileSchema, memoryTileSchema } from './schema/tile.schema';

export class ActionMapHandler {
  protected readonly dataSchemaHandler: DataSchemaHandler = new DataSchemaHandler();
  protected actionMap: ActionMap = ActionMapHandler.emptyActionMap;
  protected usedActions: ActionDataSchema[] = []; // 
  protected changeStack: ActionMap[] = []; // TODO: optimize
  protected futureStack: ActionMap[] = [];

  constructor(
    actionMap: ActionMap | null,
    protected readonly models: Model[],
    options?: {
      skipValidation?: boolean;
    }
  ) {
    if (actionMap) {
      this.actionMap = actionMap;

      if (!options?.skipValidation) {
        const { isValid } = this.validateSchema();
        if (!isValid) {
          throw new Error('Invalid action map schema');
        }
      }
    } else {
      this.createEmptyActionMap();
    }
  }

  // PUBLIC ------------------------------------------------------------------
  get currentActionMap(): ActionMap {
    return this.actionMap;
  }

  static get emptyActionMap(): ActionMap {
    return {
      id: uuidv4(),
      name: 'New Action Map',
      tiles: [],
      outputs: [],
    };
  }

  public forceUpdateActionMap(actionMap: ActionMap): ActionMap {
    this.actionMap = actionMap;

    return this.actionMap;
  }

  // TODO: implement!
  public isTileNeedsForInputs(tileId: string): boolean {
    throw new Error('Not implemented');
  }

  /**
   * Creates an empty ActionMap with a unique ID and optional name.
   * If no name is provided, the default name 'New Action Map' is used.
   * The function initializes empty arrays for tiles and outputs.
   *
   * @param {string} [name] - Optional name for the ActionMap. Defaults to 'New Action Map'.
   * @returns {ActionMap} An object representing the new ActionMap with the following properties:
   *                       - id: a unique identifier generated by uuidv4.
   *                       - name: the name of the ActionMap.
   *                       - tiles: an empty array of tiles.
   *                       - outputs: an empty array of outputs.
   */
  public createEmptyActionMap(name?: string): ActionMap {
    this.putCurrentToPreviousState();

    this.actionMap = {
      id: uuidv4(),
      name: name ?? 'New Action Map',
      tiles: [],
      outputs: [],
    };

    return this.actionMap;
  }

  /**
   * Renames the current ActionMap with a new specified name.
   * This method updates the 'name' property of the ActionMap and then returns the updated ActionMap.
   *
   * @param {string} name - The new name to be assigned to the ActionMap.
   * @returns {ActionMap} The updated ActionMap with the new name.
   */
  public renameActionMap(name: string): ActionMap {
    this.actionMap.name = name;
    return this.actionMap;
  }

  /**
   * Validates the action map against a predefined schema.
   *
   * This function compiles and applies the action map schema using AJV to
   * validate the current state of the action map. If the action map fails
   * validation, an error is thrown detailing the validation issues.
   *
   * @returns {boolean} Returns true if the action map is valid according to
   *           the schema.
   * @throws {Error} Throws an error if the action map fails schema validation,
   *         with details about the validation errors.
   */
  public validateSchema(): { isValid: boolean; errors: any[] } {
    try {
      actionMapSchema.validateSync(this.actionMap, {
        abortEarly: false,
      });

      return {
        isValid: true,
        errors: [],
      };
    } catch (e: any) {
      return {
        isValid: false,
        errors: e.errors,
      };
    }
  }

  /**
   * Retrieves the output schema for an Accessor tile.
   *
   * This function determines the schema based on the source type of the Accessor
   * tile, which is derived from its 'source' property. The source type can be
   * Memory, Model, or Constant, each requiring different handling. It fetches
   * the schema for Memory and Model types but throws an error for the Constant
   * type and unrecognized source types.
   *
   * @param {AccessorTile} tile - The Accessor tile for which to find the output schema.
   * @returns {Promise<DataSchema>} A promise that resolves to the data schema
   *           associated with the Accessor tile's source.
   * @throws {Error} Throws an error for the Constant source type or if the accessor
   *         source type is invalid.
   */
  public getAccessorOutputSchema(
    tile: AccessorTile,
  ): DataSchema {
    const source = tile.accessType;
    const sourceType = source[0];
    const sourceId = source[1];

    switch (tile.accessType) {
      case AccessorType.Memory:
        return this.getMemorySchema(sourceId);
      case AccessorType.Model: {
        const modelSchema = this.getModelSchema(sourceId);

        if ((tile as ModelAccessorTile).operation === ModelAccessOperation.FindMany) {
          return {
            type: ComplexDataType.Array,
            arrayType: modelSchema,
          };
        }

        return modelSchema;
      }
      case AccessorType.Constant:
        throw new Error('No implementation');
      case AccessorType.DataIn:
        return (tile as DataInAccessorTile).dataInProps.type;
      default:
        throw new Error(`Invalid accessor source type: ${sourceType}`);
    }
  }

  /**
   * Validates a tile against its respective schema based on the tile type.
   *
   * This function determines the appropriate validation schema to use based on
   * the tile's type (Accessor, Action, or Memory). It then compiles and applies
   * this schema using AJV to validate the tile. If the tile type is invalid or
   * the tile fails validation, an error is thrown.
   *
   * @param {Tile} tile - The tile object to be validated.
   * @returns {boolean} Returns true if the tile is valid according to its schema.
   * @throws {Error} Throws an error if the tile type is invalid or if the tile
   *         fails schema validation.
   */
  public validateTile(tile: Tile): boolean {
    if (this.tilesIntersect(tile.coordinates)) {
      throw new Error('Tile has intersections');
    }

    switch (tile.type) {
      case TileType.Accessor:
        accessorTileSchema.validate(tile, {
          abortEarly: false,
        })
        break;
      case TileType.Action:
        actionTileSchema.validate(tile, {
          abortEarly: false,
        });
        break;
      case TileType.Memory:
        memoryTileSchema.validate(tile, {
          abortEarly: false,
        });
        break;
      default:
        throw new Error(`Invalid tile type: ${tile.type}`);
    }

    return true;
  }

  /**
   * Adds a new tile to the action map.
   *
   * This function first validates the provided tile using `validateTile`. If
   * validation is successful, the tile is added to the action map's tiles array.
   * The updated action map is then returned. It assumes that `validateTile`
   * handles any necessary validation and throws errors if the tile is invalid.
   *
   * @param {Tile} tile - The tile object to be added to the action map.
   * @returns {ActionMap} The updated action map with the new tile added.
   */
  public addTile(tile: Tile, actionSchemas?: ActionDataSchema): ActionMap {
    this.validateTile(tile);

    // check action schemas and cache them
    if (tile.type === TileType.Action) {
      if (!actionSchemas) {
        throw new Error('Action schemas are not provided');
      }

      if ((tile as ActionTile).actionId !== actionSchemas.actionId) {
        throw new Error('Action schemas are not for this action');
      }

      if (!this.usedActions.some((usedAction) => usedAction.actionId === actionSchemas.actionId)) {
        this.usedActions.push(actionSchemas);
      }
    }

    this.pushNewState({
      ...this.actionMap,
      tiles: [...this.actionMap.tiles, tile],
    });

    return this.actionMap;
  }

  /**
   * Removes a tile from the action map and cleans up its associated inputs and outputs.
   *
   * This function locates a tile by its ID and removes it from the action map. It
   * also identifies and deletes all inputs and outputs associated with this tile.
   * If the tile is not found in the action map, it throws an error. The updated
   * action map is then returned.
   *
   * @param {string} id - The unique identifier of the tile to be removed.
   * @returns {ActionMap} The updated action map after the specified tile and its
   *           associated inputs and outputs have been removed.
   * @throws {Error} Throws an error if the tile with the specified ID is not found.
   */
  public removeTile(id: string): ActionMap {
    const tile = this.actionMap.tiles.find((t: Tile) => t.id === id);

    if (!tile) {
      throw new Error(`Tile ${id} not found`);
    }

    // delete inputs ant outputs for this tile
    const newOutputs = this.actionMap.outputs.filter((o) => o.outputTileId !== id && o.inputTileId !== id);

    return this.pushNewState({
      ...this.actionMap,
      tiles: this.actionMap.tiles.filter((t) => t.id !== id),
      outputs: newOutputs,
    });
  }

  /**
   * Asynchronously determines if two tiles can be connected.
   *
   * This function evaluates the possibility of connecting two tiles based on their
   * types and data schemas. It supports Memory and Action tile types with specific
   * compatibility rules. The function also utilizes a callback to return compatible
   * paths found during the compatibility check. Returns true if the tiles can be
   * connected, false otherwise.
   *
   * @param {string} fromTileId - The ID of the source tile.
   * @param {string} toTileId - The ID of the destination tile.
   * @param {(compatiblePaths: CompatiblePaths) => void} cb - A callback function
   *        that receives compatible paths determined during the evaluation.
   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating
   *           whether the tiles can be connected.
   */
  public canConnectTiles(
    fromTileId: string,
    toTileId: string,
    cb: (compatiblePaths: OutputCompatiblePaths) => void,
  ): boolean {
    const fromTile = this.actionMap.tiles.find(
      (t: Tile) => t.id === fromTileId,
    );
    const toTile = this.actionMap.tiles.find((t: Tile) => t.id === toTileId);

    let toSchema: DataSchema | null = null;

    if (toTile?.type === TileType.Memory) {
      toSchema = this.getMemorySchema(toTile.id);
    }

    if (toTile?.type === TileType.Action) {
      toSchema = this.getActionArgumentsSchema(
        (toTile as ActionTile).actionId,
      );
    }

    if (!toSchema) {
      return false;
    }

    const fromSchema = this.getTileOutputSchema(fromTile!);

    return this.dataSchemaHandler.findCompatibilities(
      fromSchema,
      toSchema,
      (source, target) => cb({
        from: source,
        to: target,
      }),
    );
  }

  /**
   * Asynchronously adds a new output to the action map and updates related tiles.
   *
   * This function adds a new output with a generated ID to the action map. It
   * ensures that the specified source and destination tiles exist and are
   * compatible for the connection. The output is then linked to these tiles based
   * on their types. Throws errors for non-existent tiles, incompatible tiles,
   * and invalid tile types.
   *
   * @param {Omit<Output, 'id'>} output - The output to be added, excluding the 'id'.
   * @param {string} fromTileId - The ID of the tile from which the output originates.
   * @param {string} toTileId - The ID of the tile to which the output connects.
   * @returns {Promise<ActionMap>} A promise that resolves to the updated action map
   *           with the new output and updated tile connections.
   * @throws {Error} Throws an error if source or destination tiles are not found,
   *           if they are not compatible, or if their types are invalid for adding outputs.
   */
  public addOutput(
    output: Omit<Output, 'id'>,
  ): ActionMap {
    // TODO: Add output validation

    const fromTile = this.actionMap.tiles.find(
      (t: Tile) => t.id === output.outputTileId,
    );

    if (!fromTile) {
      throw new Error(`Tile ${output.outputTileId} not found`);
    }

    const toTile = this.actionMap.tiles.find((t: Tile) => t.id === output.inputTileId);

    if (!toTile) {
      throw new Error(`Tile ${output.inputTileId} not found`);
    }

    // TODO: enable this
    let compatiblePaths: OutputCompatiblePaths;
    // if (
    //   !this.canConnectTiles(output.outputTileId, output.inputTileId, (paths) => {
    //     compatiblePaths = paths;
    //   })
    // ) {
    //   throw new Error(`Tiles ${output.outputTileId} and ${output.inputTileId} are not compatible`);
    // }

    // TODO: reimplement this
    // if (!output.dataMap.every((dataMap) => compatiblePaths.some((path) => path.from === dataMap.outputPath && path.to === dataMap.inputPath))) {
    //   throw new Error('Output data map is not compatible with tiles');
    // }

    const outputId = uuidv4();

    this.pushNewState({
      ...this.actionMap,
      outputs: [
        ...this.actionMap.outputs,
        {
          ...output,
          id: outputId,
        } as Output,
      ],
    });

    this.actionMap.outputs.push({
      ...output,
      id: outputId,
    } as Output);

    return this.actionMap;
  }

  /**
   * Removes an output from the action map and updates related tiles.
   *
   * This function first attempts to find and remove an output with the specified
   * ID from the action map's outputs array. If the output is not found, it throws
   * an error. It then updates all related tiles within the action map to remove
   * any references to the deleted output. This includes updating input and output
   * connections for tiles based on their type (Accessor, Action, Memory). Throws
   * an error for unrecognized tile types.
   *
   * @param {string} id - The unique identifier of the output to be removed.
   * @returns {ActionMap} The updated action map after removing the output and
   *           updating related tiles.
   * @throws {Error} Throws an error if the output with the specified ID is not found.
   * @throws {Error} Throws an error if it encounters an invalid or unrecognized tile type.
   */
  // public removeOutput(id: string): ActionMap {
  //   const index = this.actionMap.outputs.findIndex((o: Output) => o.id === id);

  //   if (index === -1) {
  //     throw new Error(`Output ${id} not found`);
  //   }

  //   this.actionMap.outputs.splice(index, 1);

  //   // remove output from tiles
  //   this.actionMap.tiles = this.actionMap.tiles.map((tile: Tile) => {
  //     const tileCopy = { ...tile };

  //     switch (tile.type) {
  //       case TileType.Accessor:
  //         (tileCopy as AccessorTile).output = (
  //           tile as AccessorTile
  //         ).output.filter((outputId: string) => outputId !== id);
  //         break;
  //       case TileType.Action:
  //         (tileCopy as ActionTile).input = (tile as ActionTile).input.filter(
  //           (outputId: string) => outputId !== id,
  //         );
  //         (tileCopy as ActionTile).output = (tile as ActionTile).output.filter(
  //           (outputId: string) => outputId !== id,
  //         );
  //         break;
  //       case TileType.Memory:
  //         (tileCopy as MemoryTile).input = (tile as MemoryTile).input.filter(
  //           (outputId: string) => outputId !== id,
  //         );
  //         break;
  //       default:
  //         throw new Error(`Invalid tile type: ${tile.type}`);
  //     }

  //     return tile;
  //   });

  //   return this.actionMap;
  // }

  /**
   * Updates the coordinates of a specific tile in the action map.
   *
   * This function locates a tile by its ID within the action map. If found, 
   * it updates the tile's start and end coordinates. If the tile is not found, 
   * it throws an error. The updated action map is then returned.
   *
   * @param {string} id - The unique identifier of the tile to be updated.
   * @param {[number, number]} start - The new starting coordinates of the tile.
   * @param {[number, number]} end - The new ending coordinates of the tile.
   * @returns {ActionMap} The updated action map containing the modified tile.
   * @throws {Error} Throws an error if the tile with the specified ID is not found.
   */
  public updateTileCoordinates(
    id: string,
    position: [number, number],
  ): ActionMap {
    const tile = this.actionMap.tiles.find((t: Tile) => t.id === id);

    if (!tile) {
      throw new Error(`Tile ${id} not found`);
    }

    const anotherTileIntersects = this.tilesIntersect(position);

    if (anotherTileIntersects) {
      throw new Error('Tile intersects with another tile');
    }

    return this.pushNewState({
      ...this.actionMap,
      tiles: this.actionMap.tiles.map((t: Tile) => {
        if (t.id === id) {
          return {
            ...t,
            coordinates: position,
          };
        }

        return t;
      }),
    });
  }

  /**
   * Checks if a tile intersects with any other tile in the action map.
   *
   * This function checks if a tile with the specified start and end coordinates
   * intersects with any other tile in the action map. If an intersection is found,
   * it returns true. Otherwise, it returns false.
   *
   * @param {[number, number]} position - The coordinates of the tile to be checked.
   * @returns {boolean} True if the tile intersects with another tile, false otherwise.
   */
  public tilesIntersect(position: [number, number]): boolean {
    return Boolean(this.actionMap.tiles.find((t: Tile) => t.coordinates[0] === position[0] && t.coordinates[1] === position[1]));
  }

  /**
   * Asynchronously retrieves the output schema for a given tile.
   *
   * Depending on the type of the tile, this function delegates to a specific
   * method to fetch the corresponding schema. It supports different tile types
   * such as Accessor, Action, and Memory. For unrecognized tile types, it throws
   * an error.
   *
   * @param {Tile} tile - The tile for which to find the output schema.
   * @returns {Promise<DataSchema>} A promise that resolves to the data schema
   *           associated with the tile's output. The specific schema returned
   *           depends on the tile type.
   * @throws {Error} Throws an error if the tile type is invalid or unrecognized.
   */
  public getTileOutputSchema(tile: Tile): DataSchema {
    switch (tile.type) {
      case TileType.Accessor:
        return this.getAccessorOutputSchema(tile as AccessorTile);
      case TileType.Action:
        return this.getActionOutputSchema((tile as ActionTile).actionId);
      case TileType.Memory:
        return this.getMemorySchema(tile.id);
      default:
        throw new Error(`Invalid tile type: ${tile.type}`);
    }
  }

  /**
   * Asynchronously retrieves the schema for the arguments of a specified action.
   *
   * This function fetches the details of the action based on the given action ID.
   * If the action is found, it parses the arguments of the action into a data
   * schema format. If the action is not found, it throws an error.
   *
   * @param {string} actionId - The unique identifier of the action.
   * @returns {Promise<DataSchema>} A promise that resolves to the data schema of
   *           the action's arguments. The schema is parsed from a JSON string.
   * @throws {Error} Throws an error if the action is not found.
   */
  public getActionArgumentsSchema(actionId: string): DataSchema {
    const action = this.usedActions.find((a) => a.actionId === actionId);

    if (!action) {
      throw new Error(`Action ${actionId} not found`);
    }

    return action.arguments;
  }

  public undo(): ActionMap {
    return this.returnToPreviousState();
  }

  public redo(): ActionMap {
    return this.returnToFutureState();
  }

  // PROTECTED -----------------------------------------------------------------
  protected getMemoryInitialSchema(tileId: string): DataSchema {
    const memory = this.getMemoryById(tileId);

    if (!memory) {
      throw new Error(`Memory ${tileId} not found`);
    }

    if (memory.memoryType === MemoryType.Model) {
      return this.getModelSchema((memory as ModelMemoryTile).modelName);
    }

    const initialMemorySchema: DataSchema = {
      type: ComplexDataType.Object,
      properties: (memory as InternalMemoryTile).properties.reduce((acc, prop) => {
        acc[prop] = {
          type: SpecialDataType.Any,
          required: true,
        };

        return acc;
      }, {}),
      required: true,
    }

    return initialMemorySchema;
  }

  protected pushNewState(actionMap: ActionMap): ActionMap {
    this.clearFutureStack();

    this.changeStack.push(this.actionMap);
    if (this.changeStack.length > 10) {
      this.changeStack.shift();
    }

    this.actionMap = actionMap;

    return actionMap;
  }

  protected returnToPreviousState(): ActionMap {
    this.putCurrentToFutureState();

    this.actionMap = this.changeStack.pop() ?? this.actionMap;

    return this.actionMap;
  }

  protected putCurrentToFutureState(): ActionMap {
    if (!this.actionMap) {
      return this.actionMap;
    }

    this.futureStack.push(this.actionMap);
    if (this.futureStack.length > 10) {
      this.futureStack.shift();
    }

    return this.actionMap;
  }

  protected putCurrentToPreviousState(): ActionMap {
    if (!this.actionMap) {
      return this.actionMap;
    }

    this.changeStack.push(this.actionMap);
    if (this.changeStack.length > 10) {
      this.changeStack.shift();
    }

    return this.actionMap;
  }

  protected clearFutureStack(): ActionMap {
    this.futureStack = [];
    return this.actionMap;
  }

  protected returnToFutureState(): ActionMap {
    this.putCurrentToPreviousState();

    this.actionMap = this.futureStack.pop() ?? this.actionMap;

    return this.actionMap;
  }

  protected getActionOutputSchema(actionId: string): DataSchema {
    const action = this.usedActions.find((a) => a.actionId === actionId);

    if (!action) {
      throw new Error(`Action ${actionId} not found`);
    }

    return action.output;
  }

  protected getModelSchema(modelName: string): DataSchema {
    const model = this.models.find((m: Model) => m.name === modelName);

    if (!model) {
      throw new Error(`Model ${modelName} not found`);
    }

    return JSON.parse(model.schema) as DataSchema;
  }

  protected getMemoryById(id: string): MemoryTile | null {
    return (this.actionMap.tiles.find(
      (tile: Tile) => tile.type === TileType.Memory && tile.id === id,
    ) || null) as MemoryTile | null;
  }

  protected getMemorySchema(id: string): DataSchema {
    // Retrieve a memory object by its ID. Throws an error if not found.
    const memory = this.getMemoryById(id);
    if (!memory) {
      throw new Error(`Memory ${id} not found`);
    }

    // Fetch the outputs associated with the memory's input IDs.
    const inOutputs = this.getOutputsByOutputTileId(memory.id);

    return this.outputsToDataSchema(inOutputs);
  }

  /**
   * Asynchronously processes a list of outputs and retrieves their corresponding data schemas.
   * This method maps each output to its source tile and extracts the relevant schema.
   * It also performs validation on the schemas and extracts sub-schemas
   * based on specified output paths.
   *
   * @param {Output[]} inOutputs - An array of outputs to be processed.
   * @returns {Promise<{argument?: string; schema: DataSchema}[]>} A promise that resolves
   * to an array of objects,
   * each containing an optional argument string and a data schema. The 'argument' corresponds
   * to the 'toArgument' property of the output,
   * and 'schema' is the resolved data schema for that output.
   *
   * @throws {Error} If the schema from the source tile is invalid or if the specified outputPath
   * does not exist in the tile's schema.
   *
   * Each output is processed as follows:
   * 1. For each output, its source tile is identified.
   * 2. The schema associated with the source tile's output is retrieved.
   * 3. If an outputPath is specified for the output, the schema for that specific path
   * is extracted and validated.
   *    If the outputPath is not valid, an error is thrown.
   * 4. If no outputPath is specified, the entire schema from the source tile is used.
   * 5. The resulting schema and any argument are added to the return array.
   */
  protected outputsToDataSchema(
    inOutputs: Output[],
  ): DataSchema {
    const dataSchema = {
      type: ComplexDataType.Object,
      properties: {},
      required: true,
    };

    inOutputs.forEach((output: Output) => {
      const sourceTile = this.getSourceTileForOutput(output.id);

      const sourceTileOutputSchema = this.getTileOutputSchema(sourceTile);

      output.dataMap.forEach((dataMap) => {
        const outputSchema = this.dataSchemaHandler.getSchemaFromPath(
          sourceTileOutputSchema,
          dataMap.outputPath,
        );

        if (!this.dataSchemaHandler.validateSchema(outputSchema)) {
          throw new Error(
            `Output field ${dataMap.outputPath} not found in tile ${sourceTile.id}`,
          );
        }

        dataSchema.properties![dataMap.inputPath] = outputSchema;
      });
    });

    return dataSchema;
  }

  protected getOutputById(id: string): Output {
    const output = this.actionMap.outputs.find((o: Output) => o.id === id);

    if (!output) {
      throw new Error(`Output ${id} not found`);
    }

    return output;
  }

  protected getOutputsByIds(ids: string[]): Output[] {
    return this.actionMap.outputs.filter((o: Output) => ids.includes(o.id));
  }

  protected getOutputsByOutputTileId(id: string): Output[] {
    return this.actionMap.outputs.filter((o: Output) => o.outputTileId === id);
  }

  protected getSourceTileForOutput(outputId: string): Tile {
    const output = this.actionMap.outputs.find((o: Output) => o.id === outputId);
    if (!output) {
      throw new Error(`Output ${outputId} not found`);
    }

    const tile = this.actionMap.tiles.find((t: Tile) => t.id === output?.outputTileId);
    if (!tile) {
      throw new Error(`Tile for output ${outputId} not found`);
    }

    return tile;
  }
}
