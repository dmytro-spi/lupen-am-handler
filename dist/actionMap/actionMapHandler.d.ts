import { ActionMap, AccessorTile, Tile, Output, OutputDirection } from './types/actionMap';
import { Model } from '../model/types/model';
import { Action } from '../action/types/action';
import { DataSchema } from '../dataSchema/types/dataSchema';
import { CompatiblePaths } from '../dataSchema/dataSchema';
export type PossibleOutput = {
    coordinates: [number, number];
    direction: OutputDirection;
    active: boolean;
};
export declare class ActionMapHandler {
    private readonly models;
    private readonly actionFetcher;
    private readonly dataSchemaHandler;
    private actionMap;
    private changeStack;
    private futureStack;
    constructor(actionMap: ActionMap | null, models: Model[], actionFetcher: (actionId: string) => Promise<Action | undefined>);
    get currentActionMap(): ActionMap;
    static get emptyActionMap(): ActionMap;
    createEmptyActionMap(name?: string): ActionMap;
    renameActionMap(name: string): ActionMap;
    validateSchema(): Promise<boolean>;
    getAccessorOutputSchema(tile: AccessorTile): Promise<DataSchema>;
    validateTile(tile: Tile): Promise<boolean>;
    addTile(tile: Tile): ActionMap;
    removeTile(id: string): ActionMap;
    canConnectTiles(fromTileId: string, toTileId: string, cb: (compatiblePaths: CompatiblePaths) => void): Promise<boolean>;
    addOutput(output: Omit<Output, 'id'>, fromTileId: string, toTileId: string): Promise<ActionMap>;
    removeOutput(id: string): ActionMap;
    updateTileCoordinates(id: string, start: [number, number], end: [number, number]): ActionMap;
    updateCoordinatesForTilesAndOutputs(tile: Tile, start: [number, number], end: [number, number]): void;
    tilesIntersect(start: [number, number], end: [number, number]): boolean;
    getTileOutputSchema(tile: Tile): Promise<DataSchema>;
    getActionArgumentsSchema(actionId: string): Promise<DataSchema>;
    getTilePossibleOutputs(tile: Tile): Promise<PossibleOutput[]>;
    undo(): ActionMap;
    redo(): ActionMap;
    private pushNewState;
    private returnToPreviousState;
    private putCurrentToFutureState;
    private putCurrentToPreviousState;
    private clearFutureStack;
    private returnToFutureState;
    private getOutputDirection;
    private getOutputCoordinates;
    private getTileNeighbors;
    private getActionOutputSchema;
    private getModelSchema;
    private getMemoryById;
    private getMemorySchema;
    private processOutputs;
    private getOutputById;
    private getOutputsByIds;
    private getSourceTileForOutput;
}
