import { ActionMap, AccessorTile, MemoryTile, Tile, Output, OutputDirection } from './types/actionMap';
import { Model } from '../model/types/model';
import { Action } from '../action/types/action';
import { DataSchema } from '../dataSchema/types/dataSchema';
import { CompatiblePaths, DataSchemaHandler } from '../dataSchema/dataSchema';
export type PossibleOutput = {
    coordinates: [number, number];
    direction: OutputDirection;
    active: boolean;
};
export declare class ActionMapHandler {
    protected readonly models: Model[];
    protected readonly actionFetcher: (actionId: string) => Promise<Action | undefined>;
    protected readonly dataSchemaHandler: DataSchemaHandler;
    protected actionMap: ActionMap;
    protected changeStack: Uint8Array[];
    protected futureStack: Uint8Array[];
    constructor(actionMap: ActionMap | null, models: Model[], actionFetcher: (actionId: string) => Promise<Action | undefined>, options?: {
        skipValidation?: boolean;
    });
    get currentActionMap(): ActionMap;
    static get emptyActionMap(): ActionMap;
    createEmptyActionMap(name?: string): ActionMap;
    renameActionMap(name: string): ActionMap;
    validateSchema(): Promise<boolean>;
    getAccessorOutputSchema(tile: AccessorTile): Promise<DataSchema>;
    validateTile(tile: Tile): Promise<boolean>;
    addTile(tile: Tile): ActionMap;
    removeTile(id: string): ActionMap;
    canConnectTiles(fromTileId: string, toTileId: string, cb: (compatiblePaths: CompatiblePaths) => void): Promise<boolean>;
    addOutput(output: Omit<Output, 'id'>, fromTileId: string, toTileId: string): Promise<ActionMap>;
    removeOutput(id: string): ActionMap;
    updateTileCoordinates(id: string, start: [number, number], end: [number, number]): ActionMap;
    updateCoordinatesForTilesAndOutputs(tile: Tile, start: [number, number], end: [number, number]): void;
    tilesIntersect(start: [number, number], end: [number, number]): boolean;
    getTileOutputSchema(tile: Tile): Promise<DataSchema>;
    getActionArgumentsSchema(actionId: string): Promise<DataSchema>;
    getTilePossibleOutputs(tile: Tile): Promise<PossibleOutput[]>;
    undo(): ActionMap;
    redo(): ActionMap;
    protected pushNewState(actionMap: ActionMap): ActionMap;
    protected returnToPreviousState(): ActionMap;
    protected putCurrentToFutureState(): ActionMap;
    protected putCurrentToPreviousState(): ActionMap;
    protected clearFutureStack(): ActionMap;
    protected returnToFutureState(): ActionMap;
    protected getOutputDirection(tile: Tile, neighbor: Tile): OutputDirection;
    protected getOutputCoordinates(tile: Tile, neighbor: Tile, direction: OutputDirection): [number, number];
    protected getTileNeighbors(tile: Tile): Tile[];
    protected getActionOutputSchema(actionId: string): Promise<DataSchema>;
    protected getModelSchema(modelName: string): DataSchema;
    protected getMemoryById(id: string): MemoryTile | null;
    protected getMemorySchema(id: string): Promise<DataSchema>;
    protected processOutputs(inOutputs: Output[]): Promise<{
        argument?: string;
        schema: DataSchema;
    }[]>;
    protected getOutputById(id: string): Output;
    protected getOutputsByIds(ids: string[]): Output[];
    protected getSourceTileForOutput(outputId: string): Tile;
}
