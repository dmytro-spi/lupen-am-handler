{"mappings":"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","sources":["src/index.ts","src/action/definitions/combine.ts","src/dataSchema/types/dataSchema.ts","src/action/categories.ts","src/model/definitions/user.ts","src/actionMap/actionMapHandler.ts","src/actionMap/types/actionMap.ts","src/actionMap/schema/actionMap.schema.ts","src/actionMap/schema/output.schema.ts","src/actionMap/schema/tile.schema.ts","src/dataSchema/schema/dataSchema.schema.ts","src/dataSchema/dataSchema.ts"],"sourcesContent":["import { combineAction } from './action/definitions/combine';\nimport { userModel } from './model/definitions/user';\nimport { ActionMapHandler } from './actionMap/actionMapHandler';\nimport { DataSchemaHandler } from './dataSchema/dataSchema';\n// import type { PossibleOutput } from './actionMap/actionMapHandler'\nimport type { CompatiblePaths } from './dataSchema/dataSchema'\nimport type { Model } from './model/types/model'\nimport {\n    AccessorTile,\n    ActionMap,\n    ActionTile,\n    CONSTANT_SELECTOR,\n    ConditionalOutput,\n    DataIn,\n    ConditionOperator,\n    DefaultOutput,\n    ForEachOutput,\n    MEMORY_SELECTOR,\n    MODEL_SELECTOR,\n    MemoryTile,\n    OUTPUT_SELECTOR,\n    Output,\n    // OutputDirection,\n    OutputGeneral,\n    OutputType,\n    Tile,\n    TileType,\n    AccessorType,\n    MemoryType,\n} from './actionMap/types/actionMap';\nimport {\n    ComplexDataType,ContentDataType,DataSchema,DataTypes,FormatDataType,SimpleDataType\n} from './dataSchema/types/dataSchema';\n\nexport {\n    TileType,\n    OutputType,\n    // OutputDirection,\n    ConditionOperator,\n    CONSTANT_SELECTOR,\n    MEMORY_SELECTOR,\n    MODEL_SELECTOR,\n    OUTPUT_SELECTOR,\n    SimpleDataType,\n    FormatDataType,\n    ActionMapHandler,\n    DataSchemaHandler,\n    ComplexDataType,\n    ContentDataType,\n    AccessorType,\n    MemoryType,\n    userModel as UserModel,\n    combineAction as CombineAction,\n}\nexport type {\n    Tile,\n    OutputGeneral,\n    Output,\n    MemoryTile,\n    ForEachOutput,\n    DefaultOutput,\n    DataIn,\n    ConditionalOutput,\n    ActionTile,\n    AccessorTile,\n    DataTypes,\n    DataSchema,\n    // PossibleOutput,\n    CompatiblePaths,\n    Model,\n    ActionMap,\n}","import { v4 as uuidv4 } from 'uuid';\nimport { ComplexDataType, DataSchema, SimpleDataType } from \"../../dataSchema/types/dataSchema\";\nimport { Action } from '../types/action';\nimport { categories } from '../categories';\n\nexport const actionArguments: DataSchema = {\n  type: ComplexDataType.Object,\n  properties: {\n    strings: {\n      type: ComplexDataType.Array,\n      description: 'An array of strings to be concatenated.',\n      arrayType: {\n        type: SimpleDataType.Text,\n      },\n      required: true,\n    },\n    divider: {\n      type: SimpleDataType.Text,\n      description:\n        'The divider to be used between strings. Default is a space.',\n      defaultValue: ' ',\n    },\n  },\n};\n\nexport const description = `\nConcatenates an array of strings into a single string.\n`;\n\nexport const implementation = `\nconst concat = (strings, divider = ' ') => {\n  const validate = ajv.compile($actionArguments$);\n  const valid = validate({ strings, divider });\n\n  if (!valid) {\n    throw new Error(\\`Invalid arguments for action $actionName$: \\${ajv.errorsText(validate.errors)}\\`);\n  }\n\n  return strings.join(divider);\n}\n`;\n\nexport const functionCall = `\nconst $variable$ = concat($strings$, $divider$);\n`;\n\nexport const actionOutput: DataSchema = {\n  type: SimpleDataType.Text,\n};\n\nexport const combineAction: Action = {\n  id: uuidv4(),\n  category: categories.find((category) => category.name === 'string')?.id || '',\n  name: 'combine',\n  label: 'Combine',\n  arguments: JSON.stringify(actionArguments),\n  description: description.trim(),\n  implementation: implementation.trim(),\n  functionCall: functionCall.trim(),\n  output: JSON.stringify(actionOutput),\n};\n","export enum SimpleDataType {\n  Text = 'text',\n  Number = 'number',\n  Date = 'date',\n  YesNo = 'yesNo',\n}\n\nexport enum FormatDataType {\n  Money = 'money',\n  PhoneNumber = 'phoneNumber',\n  Email = 'email',\n  Url = 'url',\n}\n\nexport enum ContentDataType {\n  Image = 'image',\n  Video = 'video',\n  Audio = 'audio',\n  File = 'file',\n}\n\nexport enum ComplexDataType {\n  Object = 'object',\n  Array = 'array',\n}\n\nexport type DataTypes = SimpleDataType | ComplexDataType | FormatDataType | ContentDataType;\n\nexport type DataSchema = {\n  type: DataTypes | DataTypes[];\n  properties?: {\n    [key: string]: DataSchema;\n  }\n  arrayType?: DataSchema;\n  description?: string;\n  defaultValue?: any;\n  required?: boolean;\n};\n","import { v4 as uuidv4 } from 'uuid';\nimport { Category } from './types/category';\n\nexport const categories: Category[] = [\n  {\n    id: uuidv4(),\n    name: 'string',\n    label: 'String',\n  },\n  {\n    id: uuidv4(),\n    name: 'array',\n    label: 'Array',\n  },\n  {\n    id: uuidv4(),\n    name: 'object',\n    label: 'Object',\n  },\n  {\n    id: uuidv4(),\n    name: 'math',\n    label: 'Math',\n  },\n  {\n    id: uuidv4(),\n    name: 'date',\n    label: 'Date',\n  },\n  {\n    id: uuidv4(),\n    name: 'url',\n    label: 'URL',\n  },\n  {\n    id: uuidv4(),\n    name: 'json',\n    label: 'JSON',\n  },\n  {\n    id: uuidv4(),\n    name: 'utility',\n    label: 'Utility',\n  },\n];\n","import { v4 as uuidv4 } from 'uuid';\nimport {\n  ComplexDataType,\n  DataSchema,\n  FormatDataType,\n  SimpleDataType,\n} from \"../../dataSchema/types/dataSchema\";\nimport { Model } from '../types/model';\n\nexport const userSchema: DataSchema = {\n  type: ComplexDataType.Object,\n  properties: {\n    email: {\n      type: FormatDataType.Email,\n    },\n    firstName: {\n      type: SimpleDataType.Text,\n    },\n    lastName: {\n      type: SimpleDataType.Text,\n    },\n    dateOfBirth: {\n      type: SimpleDataType.Date,\n    },\n  },\n};\n\nexport const userModel: Model = {\n  id: uuidv4(),\n  name: 'user',\n  schema: JSON.stringify(userSchema),\n};\n","import { v4 as uuidv4 } from 'uuid';\nimport {\n  ActionMap,\n  AccessorTile,\n  ActionTile,\n  MemoryTile,\n  Tile,\n  TileType,\n  Output,\n  // OutputDirection,\n  AccessorType,\n  ModelAccessorTile,\n  ModelAccessOperation,\n  DataInAccessorTile,\n} from './types/actionMap';\nimport actionMapSchema from './schema/actionMap.schema';\nimport { Model } from '../model/types/model';\nimport { Action } from '../action/types/action';\nimport { ComplexDataType, DataSchema } from '../dataSchema/types/dataSchema';\nimport { CompatiblePaths, DataSchemaHandler } from '../dataSchema/dataSchema';\nimport { accessorTileSchema, actionTileSchema, memoryTileSchema } from './schema/tile.schema';\n\n// export type PossibleOutput = {\n//   coordinates: [number, number];\n//   direction: OutputDirection;\n//   active: boolean;\n// };\n\nexport class ActionMapHandler {\n  protected readonly dataSchemaHandler: DataSchemaHandler = new DataSchemaHandler();\n  protected actionMap: ActionMap = ActionMapHandler.emptyActionMap;\n  protected changeStack: ActionMap[] = []; // TODO: optimize\n  protected futureStack: ActionMap[] = [];\n\n  constructor(\n    actionMap: ActionMap | null,\n    protected readonly models: Model[],\n    protected readonly actionFetcher: (actionId: string) => Promise<Action | undefined>,\n    options?: {\n      skipValidation?: boolean;\n    }\n  ) {\n    if (actionMap) {\n      this.actionMap = actionMap;\n\n      if (!options?.skipValidation) {\n        this.validateSchema();\n      }\n    } else {\n      this.createEmptyActionMap();\n    }\n  }\n\n  // PUBLIC ------------------------------------------------------------------\n  get currentActionMap(): ActionMap {\n    return this.actionMap;\n  }\n\n  static get emptyActionMap(): ActionMap {\n    return {\n      id: uuidv4(),\n      name: 'New Action Map',\n      tiles: [],\n      outputs: [],\n    };\n  }\n\n  /**\n   * Creates an empty ActionMap with a unique ID and optional name.\n   * If no name is provided, the default name 'New Action Map' is used.\n   * The function initializes empty arrays for tiles and outputs.\n   * \n   * @param {string} [name] - Optional name for the ActionMap. Defaults to 'New Action Map'.\n   * @returns {ActionMap} An object representing the new ActionMap with the following properties:\n   *                       - id: a unique identifier generated by uuidv4.\n   *                       - name: the name of the ActionMap.\n   *                       - tiles: an empty array of tiles.\n   *                       - outputs: an empty array of outputs.\n   */\n  public createEmptyActionMap(name?: string): ActionMap {\n    this.putCurrentToPreviousState();\n\n    this.actionMap = {\n      id: uuidv4(),\n      name: name ?? 'New Action Map',\n      tiles: [],\n      outputs: [],\n    };\n\n    return this.actionMap;\n  }\n\n  /**\n   * Renames the current ActionMap with a new specified name.\n   * This method updates the 'name' property of the ActionMap and then returns the updated ActionMap.\n   * \n   * @param {string} name - The new name to be assigned to the ActionMap.\n   * @returns {ActionMap} The updated ActionMap with the new name.\n   */\n  public renameActionMap(name: string): ActionMap {\n    this.actionMap.name = name;\n    return this.actionMap;\n  }\n\n  /**\n   * Validates the action map against a predefined schema.\n   *\n   * This function compiles and applies the action map schema using AJV to\n   * validate the current state of the action map. If the action map fails\n   * validation, an error is thrown detailing the validation issues.\n   *\n   * @returns {boolean} Returns true if the action map is valid according to\n   *           the schema.\n   * @throws {Error} Throws an error if the action map fails schema validation,\n   *         with details about the validation errors.\n   */\n  public async validateSchema(): Promise<boolean> {\n    await actionMapSchema.validate(this.actionMap, {\n      abortEarly: false,\n    });\n\n    return true;\n  }\n\n  /**\n   * Asynchronously retrieves the output schema for an Accessor tile.\n   *\n   * This function determines the schema based on the source type of the Accessor\n   * tile, which is derived from its 'source' property. The source type can be\n   * Memory, Model, or Constant, each requiring different handling. It fetches\n   * the schema for Memory and Model types but throws an error for the Constant\n   * type and unrecognized source types.\n   *\n   * @param {AccessorTile} tile - The Accessor tile for which to find the output schema.\n   * @returns {Promise<DataSchema>} A promise that resolves to the data schema\n   *           associated with the Accessor tile's source.\n   * @throws {Error} Throws an error for the Constant source type or if the accessor\n   *         source type is invalid.\n   */\n  public async getAccessorOutputSchema(\n    tile: AccessorTile,\n  ): Promise<DataSchema> {\n    const source = tile.accessType;\n    const sourceType = source[0];\n    const sourceId = source[1];\n\n    switch (tile.accessType) {\n      case AccessorType.Memory:\n        return this.getMemorySchema(sourceId);\n      case AccessorType.Model: {\n        const modelSchema = this.getModelSchema(sourceId);\n\n        if ((tile as ModelAccessorTile).operation === ModelAccessOperation.FindMany) {\n          return {\n            type: ComplexDataType.Array,\n            arrayType: modelSchema,\n          };\n        }\n\n        return modelSchema;\n      }\n      case AccessorType.Constant:\n        throw new Error('No implementation');\n      case AccessorType.DataIn:\n        return (tile as DataInAccessorTile).dataInProps.type;\n      default:\n        throw new Error(`Invalid accessor source type: ${sourceType}`);\n    }\n  }\n\n  /**\n   * Validates a tile against its respective schema based on the tile type.\n   *\n   * This function determines the appropriate validation schema to use based on\n   * the tile's type (Accessor, Action, or Memory). It then compiles and applies\n   * this schema using AJV to validate the tile. If the tile type is invalid or\n   * the tile fails validation, an error is thrown.\n   *\n   * @param {Tile} tile - The tile object to be validated.\n   * @returns {boolean} Returns true if the tile is valid according to its schema.\n   * @throws {Error} Throws an error if the tile type is invalid or if the tile\n   *         fails schema validation.\n   */\n  public async validateTile(tile: Tile): Promise<boolean> {\n    if (this.tilesIntersect(tile.coordinates)) {\n      throw new Error('Tile has intersections');\n    }\n\n    switch (tile.type) {\n      case TileType.Accessor:\n        await accessorTileSchema.validate(tile, {\n          abortEarly: false,\n        })\n        break;\n      case TileType.Action:\n        actionTileSchema.validate(tile, {\n          abortEarly: false,\n        });\n        break;\n      case TileType.Memory:\n        memoryTileSchema.validate(tile, {\n          abortEarly: false,\n        });\n        break;\n      default:\n        throw new Error(`Invalid tile type: ${tile.type}`);\n    }\n\n    return true;\n  }\n\n  /**\n   * Adds a new tile to the action map.\n   *\n   * This function first validates the provided tile using `validateTile`. If\n   * validation is successful, the tile is added to the action map's tiles array.\n   * The updated action map is then returned. It assumes that `validateTile`\n   * handles any necessary validation and throws errors if the tile is invalid.\n   *\n   * @param {Tile} tile - The tile object to be added to the action map.\n   * @returns {ActionMap} The updated action map with the new tile added.\n   */\n  public addTile(tile: Tile): ActionMap {\n    this.validateTile(tile);\n\n    this.pushNewState({\n      ...this.actionMap,\n      tiles: [...this.actionMap.tiles, tile],\n    });\n\n    return this.actionMap;\n  }\n\n  /**\n   * Removes a tile from the action map and cleans up its associated inputs and outputs.\n   *\n   * This function locates a tile by its ID and removes it from the action map. It\n   * also identifies and deletes all inputs and outputs associated with this tile.\n   * If the tile is not found in the action map, it throws an error. The updated\n   * action map is then returned.\n   *\n   * @param {string} id - The unique identifier of the tile to be removed.\n   * @returns {ActionMap} The updated action map after the specified tile and its\n   *           associated inputs and outputs have been removed.\n   * @throws {Error} Throws an error if the tile with the specified ID is not found.\n   */\n  public removeTile(id: string): ActionMap {\n    const index = this.actionMap.tiles.findIndex((t: Tile) => t.id === id);\n\n    if (index === -1) {\n      throw new Error(`Tile ${id} not found`);\n    }\n\n    // delete inputs ant outputs for this tile\n    const outputsForDelete = this.actionMap.outputs.filter(\n      (o: Output) => (this.actionMap.tiles[index] as AccessorTile | ActionTile).output?.includes(o.id)\n        || (this.actionMap.tiles[index] as MemoryTile | ActionTile).input?.includes(o.id),\n    );\n\n    outputsForDelete.forEach((o: Output) => {\n      this.removeOutput(o.id);\n    });\n\n    this.actionMap.tiles.splice(index, 1);\n\n    return this.actionMap;\n  }\n\n  /**\n   * Asynchronously determines if two tiles can be connected.\n   *\n   * This function evaluates the possibility of connecting two tiles based on their\n   * types and data schemas. It supports Memory and Action tile types with specific\n   * compatibility rules. The function also utilizes a callback to return compatible\n   * paths found during the compatibility check. Returns true if the tiles can be\n   * connected, false otherwise.\n   *\n   * @param {string} fromTileId - The ID of the source tile.\n   * @param {string} toTileId - The ID of the destination tile.\n   * @param {(compatiblePaths: CompatiblePaths) => void} cb - A callback function\n   *        that receives compatible paths determined during the evaluation.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating\n   *           whether the tiles can be connected.\n   */\n  public async canConnectTiles(\n    fromTileId: string,\n    toTileId: string,\n    cb: (compatiblePaths: CompatiblePaths) => void,\n  ): Promise<boolean> {\n    const fromTile = this.actionMap.tiles.find(\n      (t: Tile) => t.id === fromTileId,\n    );\n    const toTile = this.actionMap.tiles.find((t: Tile) => t.id === toTileId);\n\n    if (toTile?.type === TileType.Memory) {\n      return true;\n    }\n\n    if (toTile?.type !== TileType.Action) {\n      return false;\n    }\n\n    const fromSchema = await this.getTileOutputSchema(fromTile!);\n    const toSchema = await this.getActionArgumentsSchema(\n      (toTile as ActionTile).actionId,\n    );\n\n    return this.dataSchemaHandler.isSchemaPartiallyCompatibleWithTopLevelProperties(\n      fromSchema,\n      toSchema,\n      cb,\n    );\n  }\n\n  /**\n   * Asynchronously adds a new output to the action map and updates related tiles.\n   *\n   * This function adds a new output with a generated ID to the action map. It\n   * ensures that the specified source and destination tiles exist and are\n   * compatible for the connection. The output is then linked to these tiles based\n   * on their types. Throws errors for non-existent tiles, incompatible tiles,\n   * and invalid tile types.\n   *\n   * @param {Omit<Output, 'id'>} output - The output to be added, excluding the 'id'.\n   * @param {string} fromTileId - The ID of the tile from which the output originates.\n   * @param {string} toTileId - The ID of the tile to which the output connects.\n   * @returns {Promise<ActionMap>} A promise that resolves to the updated action map\n   *           with the new output and updated tile connections.\n   * @throws {Error} Throws an error if source or destination tiles are not found,\n   *           if they are not compatible, or if their types are invalid for adding outputs.\n   */\n  public async addOutput(\n    output: Omit<Output, 'id'>,\n    fromTileId: string,\n    toTileId: string,\n  ): Promise<ActionMap> {\n    const fromTile = this.actionMap.tiles.find(\n      (t: Tile) => t.id === fromTileId,\n    );\n\n    if (!fromTile) {\n      throw new Error(`Tile ${fromTileId} not found`);\n    }\n\n    const toTile = this.actionMap.tiles.find((t: Tile) => t.id === toTileId);\n\n    if (!toTile) {\n      throw new Error(`Tile ${toTileId} not found`);\n    }\n\n    let compatiblePaths: CompatiblePaths = [];\n    if (\n      !this.canConnectTiles(fromTileId, toTileId, (paths) => {\n        compatiblePaths = paths;\n      })\n    ) {\n      throw new Error(`Tiles ${fromTileId} and ${toTileId} are not compatible`);\n    }\n\n    // TODO: check compatiblePaths with output\n\n    const outputId = uuidv4();\n\n    this.actionMap.outputs.push({\n      id: outputId,\n      ...output,\n    } as Output);\n\n    switch (fromTile.type) {\n      case TileType.Accessor:\n        (fromTile as AccessorTile).output.push(outputId);\n        break;\n      case TileType.Action:\n        (fromTile as ActionTile).output.push(outputId);\n        break;\n      case TileType.Memory:\n        throw new Error('Cannot add output to memory tile');\n      default:\n        throw new Error(`Invalid tile type: ${fromTile.type}`);\n    }\n\n    switch (toTile.type) {\n      case TileType.Accessor:\n        throw new Error('Cannot add input to accessor tile');\n      case TileType.Action:\n        (toTile as ActionTile).input[parseInt(output.toArgument!)] = outputId;\n        break;\n      case TileType.Memory:\n        (toTile as MemoryTile).input.push(outputId);\n        break;\n      default:\n        throw new Error(`Invalid tile type: ${toTile.type}`);\n    }\n\n    return this.actionMap;\n  }\n\n  /**\n   * Removes an output from the action map and updates related tiles.\n   *\n   * This function first attempts to find and remove an output with the specified\n   * ID from the action map's outputs array. If the output is not found, it throws\n   * an error. It then updates all related tiles within the action map to remove\n   * any references to the deleted output. This includes updating input and output\n   * connections for tiles based on their type (Accessor, Action, Memory). Throws\n   * an error for unrecognized tile types.\n   *\n   * @param {string} id - The unique identifier of the output to be removed.\n   * @returns {ActionMap} The updated action map after removing the output and\n   *           updating related tiles.\n   * @throws {Error} Throws an error if the output with the specified ID is not found.\n   * @throws {Error} Throws an error if it encounters an invalid or unrecognized tile type.\n   */\n  public removeOutput(id: string): ActionMap {\n    const index = this.actionMap.outputs.findIndex((o: Output) => o.id === id);\n\n    if (index === -1) {\n      throw new Error(`Output ${id} not found`);\n    }\n\n    this.actionMap.outputs.splice(index, 1);\n\n    // remove output from tiles\n    this.actionMap.tiles = this.actionMap.tiles.map((tile: Tile) => {\n      const tileCopy = { ...tile };\n\n      switch (tile.type) {\n        case TileType.Accessor:\n          (tileCopy as AccessorTile).output = (\n            tile as AccessorTile\n          ).output.filter((outputId: string) => outputId !== id);\n          break;\n        case TileType.Action:\n          (tileCopy as ActionTile).input = (tile as ActionTile).input.filter(\n            (outputId: string) => outputId !== id,\n          );\n          (tileCopy as ActionTile).output = (tile as ActionTile).output.filter(\n            (outputId: string) => outputId !== id,\n          );\n          break;\n        case TileType.Memory:\n          (tileCopy as MemoryTile).input = (tile as MemoryTile).input.filter(\n            (outputId: string) => outputId !== id,\n          );\n          break;\n        default:\n          throw new Error(`Invalid tile type: ${tile.type}`);\n      }\n\n      return tile;\n    });\n\n    return this.actionMap;\n  }\n\n  /**\n   * Updates the coordinates of a specific tile in the action map.\n   *\n   * This function locates a tile by its ID within the action map. If found, \n   * it updates the tile's start and end coordinates. If the tile is not found, \n   * it throws an error. The updated action map is then returned.\n   *\n   * @param {string} id - The unique identifier of the tile to be updated.\n   * @param {[number, number]} start - The new starting coordinates of the tile.\n   * @param {[number, number]} end - The new ending coordinates of the tile.\n   * @returns {ActionMap} The updated action map containing the modified tile.\n   * @throws {Error} Throws an error if the tile with the specified ID is not found.\n   */\n  public updateTileCoordinates(\n    id: string,\n    position: [number, number],\n  ): ActionMap {\n    const tile = this.actionMap.tiles.find((t: Tile) => t.id === id);\n\n    if (!tile) {\n      throw new Error(`Tile ${id} not found`);\n    }\n\n    const anotherTileIntersects = this.tilesIntersect(position);\n\n    if (anotherTileIntersects) {\n      // this.updateCoordinatesForTilesAndOutputs(tile, start, end); // TODO: check if it's ok\n      throw new Error('Tile intersects with another tile');\n    }\n\n    tile.coordinates = position;\n\n    return this.actionMap;\n  }\n\n  /**\n   * Updates the coordinates of all tiles and outputs that intersect with a given tile.\n   *\n   * This function updates the coordinates of all tiles and outputs that intersect\n   * with a given tile. It is used to update the coordinates of a tile when it is\n   * dragged to a new location. The function checks if the tile intersects with\n   * any other tiles in the action map. If so, it updates the coordinates of the\n   * intersecting tiles and any outputs that are connected to them.\n   *\n   * @param {Tile} tile - The tile that was dragged to a new location.\n   * @param {[number, number]} start - The new starting coordinates of the tile.\n   * @param {[number, number]} end - The new ending coordinates of the tile.\n   */\n  // public updateCoordinatesForTilesAndOutputs(\n  //   tile: Tile,\n  //   start: [number, number],\n  //   end: [number, number],\n  // ): void {\n  //   // get difference between old and new coordinates\n  //   const xDiff = start[0] - tile.coordinates.start[0];\n  //   const yDiff = start[1] - tile.coordinates.start[1];\n\n  //   // get all tiles that are intersect or after the dragged tile\n  //   const tilesToMove = this.actionMap.tiles.filter((t: Tile) => {\n  //     const xStart = t.coordinates.start[0];\n  //     const xEnd = t.coordinates.end[0];\n  //     const yStart = t.coordinates.start[1];\n  //     const yEnd = t.coordinates.end[1];\n\n  //     return (\n  //       (xStart >= start[0] && yStart >= start[1])\n  //       || (xEnd >= start[0] && yEnd >= start[1])\n  //       || (xStart >= start[0] && yEnd >= start[1])\n  //       || (xEnd >= start[0] && yStart >= start[1])\n  //     );\n  //   });\n\n  //   // move tiles\n  //   tilesToMove.forEach((t: Tile) => {\n  //     t.coordinates.start[0] += xDiff;\n  //     t.coordinates.start[1] += yDiff;\n  //     t.coordinates.end[0] += xDiff;\n  //     t.coordinates.end[1] += yDiff;\n  //   });\n\n  //   // move outputs\n  //   this.actionMap.outputs.forEach((o: Output) => {\n  //     const fromTile = this.getSourceTileForOutput(o.id);\n\n  //     if (tilesToMove.includes(fromTile)) {\n  //       o.coordinates[0] += xDiff;\n  //       o.coordinates[1] += yDiff;\n  //     }\n  //   });\n  // }\n\n  /**\n   * Checks if a tile intersects with any other tile in the action map.\n   *\n   * This function checks if a tile with the specified start and end coordinates\n   * intersects with any other tile in the action map. If an intersection is found,\n   * it returns true. Otherwise, it returns false.\n   *\n   * @param {[number, number]} start - The starting coordinates of the tile to be checked.\n   * @param {[number, number]} end - The ending coordinates of the tile to be checked.\n   * @returns {boolean} True if the tile intersects with another tile, false otherwise.\n   */\n  public tilesIntersect(position: [number, number]): boolean {\n    // const xStart = start[0];\n    // const xEnd = end[0];\n    // const yStart = start[1];\n    // const yEnd = end[1];\n\n    // return this.actionMap.tiles.some((t: Tile) => {\n    //   const tXStart = t.coordinates.start[0];\n    //   const tXEnd = t.coordinates.end[0];\n    //   const tYStart = t.coordinates.start[1];\n    //   const tYEnd = t.coordinates.end[1];\n\n    //   return (\n    //     (tXStart >= xStart && tXStart <= xEnd && tYStart >= yStart && tYStart <= yEnd)\n    //     || (tXEnd >= xStart && tXEnd <= xEnd && tYEnd >= yStart && tYEnd <= yEnd)\n    //     || (tXStart >= xStart && tXStart <= xEnd && tYEnd >= yStart && tYEnd <= yEnd)\n    //     || (tXEnd >= xStart && tXEnd <= xEnd && tYStart >= yStart && tYStart <= yEnd)\n    //   );\n    // });\n    return Boolean(this.actionMap.tiles.find((t: Tile) => t.coordinates[0] === position[0] && t.coordinates[1] === position[1]));\n  }\n\n  /**\n   * Asynchronously retrieves the output schema for a given tile.\n   *\n   * Depending on the type of the tile, this function delegates to a specific\n   * method to fetch the corresponding schema. It supports different tile types\n   * such as Accessor, Action, and Memory. For unrecognized tile types, it throws\n   * an error.\n   *\n   * @param {Tile} tile - The tile for which to find the output schema.\n   * @returns {Promise<DataSchema>} A promise that resolves to the data schema\n   *           associated with the tile's output. The specific schema returned\n   *           depends on the tile type.\n   * @throws {Error} Throws an error if the tile type is invalid or unrecognized.\n   */\n  public async getTileOutputSchema(tile: Tile): Promise<DataSchema> {\n    switch (tile.type) {\n      case TileType.Accessor:\n        return this.getAccessorOutputSchema(tile as AccessorTile);\n      case TileType.Action:\n        return this.getActionOutputSchema((tile as ActionTile).actionId);\n      case TileType.Memory:\n        return this.getMemorySchema(tile.id);\n      default:\n        throw new Error(`Invalid tile type: ${tile.type}`);\n    }\n  }\n\n  /**\n   * Asynchronously retrieves the schema for the arguments of a specified action.\n   *\n   * This function fetches the details of the action based on the given action ID.\n   * If the action is found, it parses the arguments of the action into a data\n   * schema format. If the action is not found, it throws an error.\n   *\n   * @param {string} actionId - The unique identifier of the action.\n   * @returns {Promise<DataSchema>} A promise that resolves to the data schema of\n   *           the action's arguments. The schema is parsed from a JSON string.\n   * @throws {Error} Throws an error if the action is not found.\n   */\n  public async getActionArgumentsSchema(actionId: string): Promise<DataSchema> {\n    const action = await this.actionFetcher(actionId);\n\n    if (!action) {\n      throw new Error(`Action ${actionId} not found`);\n    }\n\n    return JSON.parse(action.arguments) as DataSchema;\n  }\n\n  /**\n   * Asynchronously retrieves all possible outputs for a given tile.\n   *\n   * This function calculates possible outputs by examining each neighboring tile.\n   * For each neighbor, it determines if a connection is possible, the direction \n   * of the output, and the coordinates of the output.\n   *\n   * @param {Tile} tile - The tile for which to find possible outputs.\n   * @returns {Promise<PossibleOutput[]>} A promise that resolves to an array of \n   *           possible outputs. Each output includes coordinates, direction, and \n   *           a boolean indicating if the output is active.\n   */\n  // public async getTilePossibleOutputs(tile: Tile): Promise<PossibleOutput[]> {\n  //   const neighbors = await this.getTileNeighbors(tile);\n\n  //   const possibleOutputs: PossibleOutput[] = await Promise.all(\n  //     neighbors.map(async (neighbor: Tile) => {\n  //       const canBeConnected = await this.canConnectTiles(tile.id, neighbor.id, () => {});\n\n  //       const direction = this.getOutputDirection(tile, neighbor);\n  //       const coordinates = this.getOutputCoordinates(tile, neighbor, direction);\n\n  //       return {\n  //         coordinates,\n  //         direction,\n  //         active: canBeConnected,\n  //       };\n  //     }),\n  //   );\n\n  //   return possibleOutputs;\n  // }\n\n  public undo(): ActionMap {\n    return this.returnToPreviousState();\n  }\n\n  public redo(): ActionMap {\n    return this.returnToFutureState();\n  }\n\n  // PROTECTED -----------------------------------------------------------------\n  protected pushNewState(actionMap: ActionMap): ActionMap {\n    this.clearFutureStack();\n\n    this.changeStack.push(this.actionMap);\n    if (this.changeStack.length > 10) {\n      this.changeStack.shift();\n    }\n\n    this.actionMap = actionMap;\n\n    return actionMap;\n  }\n\n  protected returnToPreviousState(): ActionMap {\n    this.putCurrentToFutureState();\n\n    return this.changeStack.pop() ?? this.actionMap;\n  }\n\n  protected putCurrentToFutureState(): ActionMap {\n    if (!this.actionMap) {\n      return this.actionMap;\n    }\n\n    this.futureStack.push(this.actionMap);\n    if (this.futureStack.length > 10) {\n      this.futureStack.shift();\n    }\n\n    return this.actionMap;\n  }\n\n  protected putCurrentToPreviousState(): ActionMap {\n    if (!this.actionMap) {\n      return this.actionMap;\n    }\n\n    this.changeStack.push(this.actionMap);\n    if (this.changeStack.length > 10) {\n      this.changeStack.shift();\n    }\n\n    return this.actionMap;\n  }\n\n  protected clearFutureStack(): ActionMap {\n    this.futureStack = [];\n    return this.actionMap;\n  }\n\n  protected returnToFutureState(): ActionMap {\n    this.putCurrentToPreviousState();\n\n    return this.futureStack.pop() ?? this.actionMap;\n  }\n\n  // protected getOutputDirection(tile: Tile, neighbor: Tile): OutputDirection {\n  //   const xStart = tile.coordinates.start[0];\n  //   const xEnd = tile.coordinates.end[0];\n  //   const yStart = tile.coordinates.start[1];\n  //   const yEnd = tile.coordinates.end[1];\n\n  //   const neighborXStart = neighbor.coordinates.start[0];\n  //   const neighborXEnd = neighbor.coordinates.end[0];\n  //   const neighborYStart = neighbor.coordinates.start[1];\n  //   const neighborYEnd = neighbor.coordinates.end[1];\n\n  //   if (neighborXStart === xEnd) {\n  //     return OutputDirection.Right;\n  //   }\n\n  //   if (neighborXEnd === xStart) {\n  //     return OutputDirection.Left;\n  //   }\n\n  //   if (neighborYStart === yEnd) {\n  //     return OutputDirection.Down;\n  //   }\n\n  //   if (neighborYEnd === yStart) {\n  //     return OutputDirection.Up;\n  //   }\n\n  //   throw new Error('Invalid output direction');\n  // }\n\n  // protected getOutputCoordinates(\n  //   tile: Tile,\n  //   neighbor: Tile,\n  //   direction: OutputDirection,\n  // ): [number, number] {\n  //   const neighborXStart = neighbor.coordinates.start[0];\n  //   const neighborXEnd = neighbor.coordinates.end[0];\n  //   const neighborYStart = neighbor.coordinates.start[1];\n  //   const neighborYEnd = neighbor.coordinates.end[1];\n\n  //   switch (direction) {\n  //     case OutputDirection.Down:\n  //       return [neighborXStart, neighborYStart - 1];\n  //     case OutputDirection.Right:\n  //       return [neighborXStart - 1, neighborYStart];\n  //     case OutputDirection.Up:\n  //       return [neighborXStart, neighborYEnd + 1];\n  //     case OutputDirection.Left:\n  //       return [neighborXEnd + 1, neighborYStart];\n  //     default:\n  //       throw new Error('Invalid output direction');\n  //   }\n  // }\n\n  // protected getTileNeighbors(tile: Tile): Tile[] {\n  //   const neighbors: Tile[] = [];\n\n  //   // get coordinates of current tile and find any tiles that have\n  //   // coordinates +1 by x right, -1 by x left, +1 by y bottom, -1 by y top\n  //   const xStart = tile.coordinates.start[0];\n  //   const xEnd = tile.coordinates.end[0];\n  //   const yStart = tile.coordinates.start[1];\n  //   const yEnd = tile.coordinates.end[1];\n\n  //   this.actionMap.tiles.forEach((t: Tile) => {\n  //     if (\n  //       (t.coordinates.start[0] === xEnd\n  //         && t.coordinates.start[1] >= yStart\n  //         && t.coordinates.start[1] <= yEnd)\n  //       || (t.coordinates.end[0] === xStart\n  //         && t.coordinates.end[1] >= yStart\n  //         && t.coordinates.end[1] <= yEnd)\n  //       || (t.coordinates.start[1] === yEnd\n  //         && t.coordinates.start[0] >= xStart\n  //         && t.coordinates.start[0] <= xEnd)\n  //       || (t.coordinates.end[1] === yStart\n  //         && t.coordinates.end[0] >= xStart\n  //         && t.coordinates.end[0] <= xEnd)\n  //     ) {\n  //       neighbors.push(t);\n  //     }\n  //   });\n\n  //   return neighbors;\n  // }\n\n  protected async getActionOutputSchema(actionId: string): Promise<DataSchema> {\n    const action = await this.actionFetcher(actionId);\n\n    if (!action) {\n      throw new Error(`Action ${actionId} not found`);\n    }\n\n    return JSON.parse(action.output) as DataSchema;\n  }\n\n  protected getModelSchema(modelName: string): DataSchema {\n    const model = this.models.find((m: Model) => m.name === modelName);\n\n    if (!model) {\n      throw new Error(`Model ${modelName} not found`);\n    }\n\n    return JSON.parse(model.schema) as DataSchema;\n  }\n\n  protected getMemoryById(id: string): MemoryTile | null {\n    return (this.actionMap.tiles.find(\n      (tile: Tile) => tile.type === TileType.Memory && tile.id === id,\n    ) || null) as MemoryTile | null;\n  }\n\n  protected async getMemorySchema(id: string): Promise<DataSchema> {\n    // Retrieve a memory object by its ID. Throws an error if not found.\n    const memory = this.getMemoryById(id);\n    if (!memory) {\n      throw new Error(`Memory ${id} not found`);\n    }\n\n    // Fetch the outputs associated with the memory's input IDs.\n    const inOutputs = this.getOutputsByIds(memory.input);\n\n    // This array will hold the schemas for each input.\n    const inputSchemas: {\n      argument?: string;\n      schema: DataSchema;\n    }[] = await this.processOutputs(inOutputs);\n\n    // If there's only one input schema without an argument, return it directly.\n    if (inputSchemas.length === 1 && !inputSchemas[0].argument) {\n      return inputSchemas[0].schema;\n    }\n\n    // Prepare to construct a combined schema for multiple inputs.\n    const properties: {\n      [x: string]: any;\n    } = {};\n\n    // For each input schema, add a reference to it in the properties of the combined schema.\n    inputSchemas.forEach(\n      (schema: { argument?: string; schema: DataSchema }) => {\n        if (schema.argument) {\n          properties[schema.argument] = schema.schema;\n        }\n      },\n    );\n\n    // Return the combined schema.\n    return {\n      type: ComplexDataType.Object,\n      properties,\n    };\n  }\n\n  /**\n   * Asynchronously processes a list of outputs and retrieves their corresponding data schemas.\n   * This method maps each output to its source tile and extracts the relevant schema.\n   * It also performs validation on the schemas and extracts sub-schemas\n   * based on specified output paths.\n   *\n   * @param {Output[]} inOutputs - An array of outputs to be processed.\n   * @returns {Promise<{argument?: string; schema: DataSchema}[]>} A promise that resolves\n   * to an array of objects,\n   * each containing an optional argument string and a data schema. The 'argument' corresponds\n   * to the 'toArgument' property of the output,\n   * and 'schema' is the resolved data schema for that output.\n   *\n   * @throws {Error} If the schema from the source tile is invalid or if the specified outputPath\n   * does not exist in the tile's schema.\n   *\n   * Each output is processed as follows:\n   * 1. For each output, its source tile is identified.\n   * 2. The schema associated with the source tile's output is retrieved.\n   * 3. If an outputPath is specified for the output, the schema for that specific path\n   * is extracted and validated.\n   *    If the outputPath is not valid, an error is thrown.\n   * 4. If no outputPath is specified, the entire schema from the source tile is used.\n   * 5. The resulting schema and any argument are added to the return array.\n   */\n  protected async processOutputs(\n    inOutputs: Output[],\n  ): Promise<{ argument?: string; schema: DataSchema }[]> {\n    const inputSchemas = await Promise.all(\n      inOutputs.map(async (output) => {\n        const sourceTile = this.getSourceTileForOutput(output.id);\n\n        // Refactored schema retrieval into a separate function for clarity\n        const sourceTileOutputSchema =\n          await this.getTileOutputSchema(sourceTile);\n\n        let outputSchema;\n\n        if (output.outputPath) {\n          if (!this.dataSchemaHandler.validateSchema(sourceTileOutputSchema)) {\n            throw new Error(`Invalid schema for tile ${sourceTile.id}`);\n          }\n\n          outputSchema = this.dataSchemaHandler.getSchemaFromPath(\n            sourceTileOutputSchema,\n            output.outputPath,\n          );\n\n          if (!this.dataSchemaHandler.validateSchema(outputSchema)) {\n            throw new Error(\n              `Output field ${output.outputPath} not found in tile ${sourceTile.id}`,\n            );\n          }\n        } else {\n          outputSchema = sourceTileOutputSchema;\n        }\n\n        return {\n          argument: output.toArgument,\n          schema: outputSchema,\n        };\n      }),\n    );\n\n    return inputSchemas;\n  }\n\n  protected getOutputById(id: string): Output {\n    const output = this.actionMap.outputs.find((o: Output) => o.id === id);\n\n    if (!output) {\n      throw new Error(`Output ${id} not found`);\n    }\n\n    return output;\n  }\n\n  protected getOutputsByIds(ids: string[]): Output[] {\n    return ids.map((id: string) => this.getOutputById(id));\n  }\n\n  protected getSourceTileForOutput(outputId: string): Tile {\n    const tile = this.actionMap.tiles.find((t: Tile) => {\n      switch (t.type) {\n        case TileType.Accessor:\n          return (t as AccessorTile).output.includes(outputId);\n        case TileType.Action:\n          return (t as ActionTile).output.includes(outputId);\n        case TileType.Memory:\n          return false;\n        default:\n          throw new Error(`Invalid tile type: ${t.type}`);\n      }\n    });\n\n    if (!tile) {\n      throw new Error(`Tile for output ${outputId} not found`);\n    }\n\n    return tile;\n  }\n\n  // protected checkIfTileHasIntersections(tile: Tile): boolean {\n  //   const xStart = tile.coordinates.start[0];\n  //   const xEnd = tile.coordinates.end[0];\n  //   const yStart = tile.coordinates.start[1];\n  //   const yEnd = tile.coordinates.end[1];\n\n  //   return this.actionMap.tiles.some((t: Tile) => {\n  //     const tXStart = t.coordinates.start[0];\n  //     const tXEnd = t.coordinates.end[0];\n  //     const tYStart = t.coordinates.start[1];\n  //     const tYEnd = t.coordinates.end[1];\n\n  //     return (\n  //       // Existing corner checks\n  //       (tXStart >= xStart && tXStart <= xEnd && tYStart >= yStart && tYStart <= yEnd) ||\n  //       (tXEnd >= xStart && tXEnd <= xEnd && tYEnd >= yStart && tYEnd <= yEnd) ||\n  //       (tXStart >= xStart && tXStart <= xEnd && tYEnd >= yStart && tYEnd <= yEnd) ||\n  //       (tXEnd >= xStart && tXEnd <= xEnd && tYStart >= yStart && tYStart <= yEnd) ||\n\n  //       // Check if tile is completely within t\n  //       (xStart >= tXStart && xEnd <= tXEnd && yStart >= tYStart && yEnd <= tYEnd) ||\n\n  //       // Check if t is completely within tile\n  //       (tXStart >= xStart && tXEnd <= xEnd && tYStart >= yStart && tYEnd <= yEnd)\n  //     );\n  //   });\n  // }\n}\n","import { DataSchema } from '../../dataSchema/types/dataSchema';\n\n// User language types ---------------------------------------------------------\nexport const MEMORY_SELECTOR = (id: string) => `memory::${id}`;\nexport const CONSTANT_SELECTOR = (name: string) => `constant::${name}`;\nexport const MODEL_SELECTOR = (name: string) => `model::${name}`;\nexport const OUTPUT_SELECTOR = (id: string) => `output::${id}`;\n\n// condition operators\nexport enum ConditionOperator {\n  Equal = '==',\n  StrongEqual = '===',\n  NotEqual = '!=',\n  StrongNotEqual = '!==',\n  GreaterThan = '>',\n  GreaterThanOrEqual = '>=',\n  LessThan = '<',\n  LessThanOrEqual = '<=',\n}\n\n// Output types ----------------------------------------------------------------\n// export enum OutputDirection {\n//   Down = 'down',\n//   Right = 'right',\n//   Up = 'up',\n//   Left = 'left',\n// }\n\nexport enum OutputType {\n  Default = 'default',\n  Conditional = 'conditional',\n  ForEach = 'forEach',\n}\n\nexport type OutputGeneral = {\n  id: string;\n  // direction: OutputDirection;\n  // coordinates: [number, number];\n  toArgument?: string;\n  type: OutputType;\n  outputPath?: string; // .field.nestedField\n};\n\nexport type DefaultOutput = OutputGeneral & {\n  type: OutputType.Default;\n};\n\nexport type ConditionalOutput = OutputGeneral & {\n  type: OutputType.Conditional;\n  condition: string;\n};\n\nexport type ForEachOutput = OutputGeneral & {\n  type: OutputType.ForEach;\n};\n\nexport type Output = DefaultOutput | ConditionalOutput | ForEachOutput;\n\n// Tile types ------------------------------------------------------------------\nexport enum TileType {\n  Accessor = 'accessor',\n  Action = 'action',\n  Memory = 'memory',\n}\n\nexport type TileGeneral = {\n  id: string;\n  coordinates: [number, number];\n  type: TileType;\n};\n\nexport enum AccessorType {\n  Model = 'model',\n  Constant = 'constant',\n  Memory = 'memory',\n  DataIn = 'dataIn',\n}\n\nexport type AccessorTile = TileGeneral & {\n  output: Output['id'][];\n  accessType: AccessorType;\n};\n\nexport type ConstantAccessorTile = AccessorTile & {\n  accessType: AccessorType.Constant;\n  constantName: string;\n};\n\nexport type DataInAccessorTile = AccessorTile & {\n  accessType: AccessorType.DataIn;\n  dataInProps: DataIn;\n};\n\nexport type MemoryAccessorTile = AccessorTile & {\n  accessType: AccessorType.Memory;\n  memoryTileId: string;\n};\n\nexport enum  ModelAccessOperation {\n  FindOne = 'findOne',\n  FindMany = 'findMany',\n  FindFirst = 'findFirst',\n  FindLast = 'findLast',\n};\n\nexport type ModelAccessorTile = AccessorTile & {\n  accessType: AccessorType.Model;\n  modelName: string;\n  query: string;\n  operation: ModelAccessOperation;\n};\n\nexport type ActionTile = TileGeneral & {\n  output: string[];\n  actionId: string;\n  input: Output['id'][];\n};\n\nexport enum MemoryType {\n  DataOut = 'dataOut',\n  Internal = 'internal',\n  Model = 'model',\n}\n\nexport type MemoryTile = TileGeneral & {\n  input: Output['id'][];\n  memoryType: MemoryType;\n};\n\nexport enum ModelMemoryOperation {\n  Create = 'create',\n  Update = 'update',\n  Delete = 'delete',\n};\n\nexport type ModelMemoryTile = MemoryTile & {\n  memoryType: MemoryType.Model;\n  modelName: string;\n  query: string;\n  operation: ModelMemoryOperation;\n};\n\nexport type Tile = AccessorTile\n| ActionTile\n| MemoryTile\n| ModelMemoryTile\n| ModelAccessorTile\n| ConstantAccessorTile\n| DataInAccessorTile\n| MemoryAccessorTile;\n\n// Data in types ---------------------------------------------------------------\nexport type DataIn = {\n  name: string;\n  label: string;\n  type: DataSchema;\n  required: boolean;\n  defaultValue?: any;\n};\n\n// Action map types ------------------------------------------------------------\nexport type ActionMap = {\n  id: string;\n  name: string;\n  outputs: Output[];\n  tiles: Tile[];\n};\n","import * as yup from 'yup';\nimport outputSchema from './output.schema';\nimport tileSchema from './tile.schema';\n\n// ActionMap schema\nconst actionMapSchema = yup.object().shape({\n  id: yup.string().required(),\n  name: yup.string().required(),\n  outputs: yup.array().of(outputSchema).required(),\n  tiles: yup.array().of(tileSchema).required(),\n});\n\nexport default actionMapSchema;\n","import * as yup from 'yup';\nimport { OutputType } from '../types/actionMap';\n\n// OutputDirection schema\n// const outputDirectionSchema = yup\n//   .mixed<OutputDirection>()\n//   .oneOf(Object.values(OutputDirection));\n\n// OutputType schema\nconst outputTypeSchema = yup\n  .mixed<OutputType>()\n  .oneOf(Object.values(OutputType));\n\n// Base OutputGeneral schema\nconst outputGeneralSchema = yup.object().shape({\n  id: yup.string().required(),\n  // direction: outputDirectionSchema.required(),\n  // coordinates: yup\n  //   .array()\n  //   .of(yup.number())\n  //   .min(2)\n  //   .max(2)\n  //   .required(),\n  toArgument: yup.string().nullable(),\n  type: outputTypeSchema.required(),\n  outputPath: yup.string().nullable(),\n});\n\n// DefaultOutput schema\nconst defaultOutputSchema = outputGeneralSchema\n  .concat(yup.object({\n    type: yup.mixed().oneOf([OutputType.Default]),\n  }));\n\n// ConditionalOutput schema\nconst conditionalOutputSchema = outputGeneralSchema\n  .concat(yup.object({\n    type: yup.mixed().oneOf([OutputType.Conditional]),\n    condition: yup.string().required(),\n  }));\n\n// ForEachOutput schema\nconst forEachOutputSchema = outputGeneralSchema\n  .concat(yup.object({\n    type: yup.mixed().oneOf([OutputType.ForEach]),\n  }));\n\n// Combined Output schema\nconst outputSchema = yup.lazy(value => {\n  switch (value.type) {\n    case OutputType.Default:\n      return defaultOutputSchema;\n    case OutputType.Conditional:\n      return conditionalOutputSchema;\n    case OutputType.ForEach:\n      return forEachOutputSchema;\n    default:\n      return yup.object().shape({});\n  }\n});\n\nexport default outputSchema;\n","import * as yup from 'yup';\nimport { AccessorType, MemoryType, ModelAccessOperation, ModelMemoryOperation, TileType } from '../types/actionMap';\nimport dataSchemaSchema from '../../dataSchema/schema/dataSchema.schema';\n\nexport const dataInSchema = yup.object().shape({\n  name: yup.string().required(),\n  label: yup.string().required(),\n  type: dataSchemaSchema.required(),\n  required: yup.boolean().required(),\n  defaultValue: yup.mixed().nullable(),\n});\n\n// TileType schema\nexport const tileTypeSchema = yup\n  .mixed<TileType>()\n  .oneOf(Object.values(TileType));\n\n// AccessorType schema\nexport const accessorTypeSchema = yup\n  .mixed<AccessorType>()\n  .oneOf(Object.values(AccessorType));\n\n// ModelAccessOperation schema\nexport const modelAccessOperationSchema = yup\n  .mixed<ModelAccessOperation>()\n  .oneOf(Object.values(ModelAccessOperation));\n\n// ModelMemoryOperation schema\nexport const modelMemoryOperationSchema = yup\n  .mixed<ModelMemoryOperation>()\n  .oneOf(Object.values(ModelMemoryOperation));\n\n// Base TileGeneral schema\nexport const tileGeneralSchema = yup.object().shape({\n  id: yup.string().required(),\n  coordinates: yup.array().of(yup.number()).min(2).max(2).required(),\n  type: tileTypeSchema.required(),\n});\n\n// AccessorTile schema\nexport const accessorTileSchema = tileGeneralSchema\n  .concat(yup.object({\n    output: yup.array().of(yup.string()).required(),\n    accessType: accessorTypeSchema.required(),\n  }));\n\n// ConstantAccessorTile schema\nexport const constantAccessorTileSchema = accessorTileSchema\n  .concat(yup.object({\n    accessType: yup.mixed().oneOf([AccessorType.Constant]),\n    constantName: yup.string().required(),\n  }));\n\n// DataInAccessorTile schema\nexport const dataInAccessorTileSchema = accessorTileSchema\n  .concat(yup.object({\n    accessType: yup.mixed().oneOf([AccessorType.DataIn]),\n    dataInProps: dataInSchema.required(),\n  }));\n\n// MemoryAccessorTile schema\nexport const memoryAccessorTileSchema = accessorTileSchema\n  .concat(yup.object({\n    accessType: yup.mixed().oneOf([AccessorType.Memory]),\n    memoryTileId: yup.string().required(),\n  }));\n\n// ModelAccessorTile schema\nexport const modelAccessorTileSchema = accessorTileSchema\n  .concat(yup.object({\n    accessType: yup.mixed().oneOf([AccessorType.Model]),\n    modelName: yup.string().required(),\n    query: yup.string().required(),\n    operation: modelAccessOperationSchema.required(),\n  }));\n\n// ActionTile schema\nexport const actionTileSchema = tileGeneralSchema\n  .concat(yup.object({\n    output: yup.array().of(yup.string()).required(),\n    actionId: yup.string().required(),\n    input: yup.array().of(yup.string()).required(),\n  }));\n\n// MemoryTile schema\nexport const memoryTileSchema = tileGeneralSchema\n  .concat(yup.object({\n    input: yup.array().of(yup.string()).required(),\n    memoryType: yup\n      .mixed<MemoryType>()\n      .oneOf(Object.values(MemoryType))\n      .required(),\n  }));\n\n// ModelMemoryTile schema\nexport const modelMemoryTileSchema = memoryTileSchema\n  .concat(yup.object({\n    memoryType: yup.mixed().oneOf([MemoryType.Model]),\n    modelName: yup.string().required(),\n    query: yup.string().required(),\n    operation: modelMemoryOperationSchema.required(),\n  }));\n\n// Combined Tile schema\nconst tileSchema = yup.lazy(value => {\n  switch (value.type) {\n    case TileType.Accessor:\n      switch (value.accessType) {\n        case AccessorType.Constant:\n          return constantAccessorTileSchema;\n        case AccessorType.DataIn:\n          return dataInAccessorTileSchema;\n        case AccessorType.Memory:\n          return memoryAccessorTileSchema;\n        case AccessorType.Model:\n          return modelAccessorTileSchema;\n        default:\n          return accessorTileSchema;\n      }\n    case TileType.Action:\n      return actionTileSchema;\n    case TileType.Memory:\n      return (value.memoryType === MemoryType.Model) ? modelMemoryTileSchema : memoryTileSchema;\n    default:\n      return yup.object().shape({\n        type: yup.mixed<TileType>().oneOf(Object.values(TileType)).required(),\n      });\n  }\n});\n\nexport default tileSchema;\n","import * as yup from 'yup';\nimport { ComplexDataType, ContentDataType, FormatDataType, SimpleDataType } from '../types/dataSchema';\n\n// SimpleDataType, FormatDataType, ContentDataType, ComplexDataType enums\nconst simpleDataTypeSchema = yup.mixed<SimpleDataType>().oneOf(Object.values(SimpleDataType));\nconst formatDataTypeSchema = yup.mixed<FormatDataType>().oneOf(Object.values(FormatDataType));\nconst contentDataTypeSchema = yup.mixed<ContentDataType>().oneOf(Object.values(ContentDataType));\nconst complexDataTypeSchema = yup.mixed<ComplexDataType>().oneOf(Object.values(ComplexDataType));\n\n// DataTypes schema\nconst dataTypesSchema = yup.lazy(value => \n  yup.array().of(\n    yup.mixed().oneOf([\n      simpleDataTypeSchema, \n      formatDataTypeSchema, \n      contentDataTypeSchema, \n      complexDataTypeSchema\n    ])\n  ).required()\n);\n\n// Recursive DataSchema schema\nconst dataSchema = yup.object({\n  type: dataTypesSchema,\n  properties: yup.lazy((value) => \n    yup.object().shape(\n      Object.keys(value).reduce((shape, key) => {\n        shape[key] = dataSchema;\n        return shape;\n      }, {})\n    ).nullable()\n  ),\n  arrayType: yup.lazy(() => dataSchema.nullable()),\n  description: yup.string().nullable(),\n  defaultValue: yup.mixed().nullable(),\n  required: yup.boolean().nullable(),\n});\n\nexport default dataSchema;\n","import {\n  ComplexDataType,\n  DataSchema,\n  SimpleDataType,\n  DataTypes,\n  ContentDataType,\n} from './types/dataSchema';\n\ntype PropertyItem = {\n  name: string;\n  type: DataTypes | DataTypes[];\n  children?: PropertyItem[];\n};\n\ntype PropertyTree = PropertyItem[];\n\nexport type CompatiblePaths = { from: string; to: string }[];\n\nexport class DataSchemaHandler {\n  public getPropertiesTree(schema: DataSchema): PropertyTree {\n    return this.getPropertiesTreeFromSchema(schema);\n  }\n\n  public isSchemasCompatible(schema: DataSchema, schemaToCompare: DataSchema): boolean {\n    return this.isSchemasCompatibleRecursive(schema, schemaToCompare);\n  }\n\n  public isSchemaPartiallyCompatible(\n    schemaFrom: DataSchema,\n    schemaTo: DataSchema,\n    cb: (compatiblePaths: string[]) => any,\n  ): boolean {\n    const compatiblePaths: string[] = [];\n\n    this.walkThroughPropertiesRecursive(schemaFrom, (partialSchema, path) => {\n      if (this.isSchemasCompatibleRecursive(partialSchema, schemaTo)) {\n        compatiblePaths.push(path);\n      }\n    });\n\n    cb(compatiblePaths);\n\n    return compatiblePaths.length > 0;\n  }\n\n  public isSchemaPartiallyCompatibleWithTopLevelProperties(\n    schemaFrom: DataSchema,\n    schemaTo: DataSchema,\n    cb: (compatiblePaths: CompatiblePaths) => any,\n  ): boolean {\n    const compatiblePaths: CompatiblePaths = [];\n\n    Object.entries(schemaTo.properties || {}).forEach(([key, value]) => {\n      this.walkThroughPropertiesRecursive(schemaFrom, (partialSchema, path) => {\n        if (this.isSchemasCompatibleRecursive(partialSchema, value)) {\n          compatiblePaths.push({ from: path, to: `.${key}` });\n        }\n      });\n    });\n\n    cb(compatiblePaths);\n\n    return compatiblePaths.length > 0;\n  }\n\n  public validateSchema(schema: DataSchema): boolean {\n    if (schema.type !== ComplexDataType.Object && schema.properties) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public walkThroughPropertiesRecursive(\n    schema: DataSchema,\n    callback: (partialSchema: DataSchema, path: string) => void, // path - like lodash path\n  ) {\n    switch (schema.type) {\n      case SimpleDataType.Text:\n      case SimpleDataType.Number:\n      case SimpleDataType.Date:\n      case SimpleDataType.YesNo:\n      case ContentDataType.File:\n      case ContentDataType.Image:\n      case ContentDataType.Video:\n      case ContentDataType.Audio:\n        callback(schema, '');\n        break;\n      case ComplexDataType.Object:\n        Object.entries(schema.properties || {}).forEach(\n          ([key, value]: [string, DataSchema]) => {\n            this.walkThroughPropertiesRecursive(\n              value,\n              (partialSchema, path) => {\n                callback(partialSchema, `.${key}${path}`);\n              },\n            );\n          },\n        );\n        break;\n      case ComplexDataType.Array:\n        this.walkThroughPropertiesRecursive(\n          schema.arrayType!,\n          (dSchema, path) => {\n            callback(dSchema, `[]${path}`);\n          },\n        );\n        break;\n      default:\n        throw new Error(`Unsupported data type: ${schema.type}`);\n    }\n  }\n\n  public getSchemaFromPath(schema: DataSchema, path: string): DataSchema {\n    const pathParts = path.split(/\\.|\\[\\]/g).filter((part) => part !== '');\n    let currentSchema = schema;\n\n    for (const pathPart of pathParts) {\n      switch (currentSchema.type) {\n        case ComplexDataType.Object:\n          currentSchema = currentSchema.properties![pathPart];\n          break;\n        case ComplexDataType.Array:\n          currentSchema = currentSchema.arrayType!;\n          break;\n        default:\n          throw new Error(\n            `Unsupported data type: ${currentSchema.type} at path: ${path}`,\n          );\n      }\n    }\n\n    return currentSchema;\n  }\n\n  private isSchemasCompatibleRecursive(\n    schemaFrom: DataSchema,\n    schemaTo: DataSchema,\n  ): boolean {\n    if (schemaFrom.type !== schemaTo.type) {\n      return false;\n    }\n\n    switch (schemaFrom.type) {\n      case SimpleDataType.Text:\n      case SimpleDataType.Number:\n      case SimpleDataType.Date:\n      case SimpleDataType.YesNo:\n      case ContentDataType.File:\n      case ContentDataType.Image:\n      case ContentDataType.Video:\n      case ContentDataType.Audio:\n        return true;\n      case ComplexDataType.Object:\n        return Object.entries(schemaFrom.properties || {}).every(\n          ([key, value]) => {\n            const schemaToProperty = schemaTo.properties?.[key];\n            if (!schemaToProperty) {\n              return false;\n            }\n            return this.isSchemasCompatibleRecursive(value, schemaToProperty);\n          },\n        );\n      case ComplexDataType.Array:\n        return this.isSchemasCompatibleRecursive(\n          schemaFrom.arrayType!,\n          schemaTo.arrayType!,\n        );\n      default:\n        throw new Error(`Unsupported data type: ${schemaFrom.type}`);\n    }\n  }\n\n  private getPropertiesTreeFromSchema(schema: DataSchema): PropertyTree {\n    switch (schema.type) {\n      case SimpleDataType.Text:\n      case SimpleDataType.Number:\n      case SimpleDataType.Date:\n      case SimpleDataType.YesNo:\n        return [];\n      case ComplexDataType.Array:\n        return this.getPropertiesTreeFromSchema(schema.arrayType!);\n      case ComplexDataType.Object:\n        return Object.entries(schema.properties || {}).map(\n          ([key, value]: [string, DataSchema]) => ({\n            name: key,\n            type: value.type,\n            children: this.getPropertiesTreeFromSchema(value),\n          }),\n        );\n      default:\n        throw new Error(`Unsupported data type: ${schema.type}`);\n    }\n  }\n}\n"],"names":[],"version":3,"file":"module.js.map"}