{"mappings":";;;;;;UEAY;;;;;GAAA,8CAAA;;UAOA;;;;;GAAA,8CAAA;;UAOA;;;;;GAAA,8CAAA;;UAOA;;;GAAA,8CAAA;;UAKA;;GAAA,8CAAA;;UAmBA;;;GAAA,6CAAA;;UAKA;;;;GAAA,8CAAA;;;;AC/CL,MAAM,4CAAyB;IACpC;QACE,IAAI,CAAA,GAAA,SAAK;QACT,MAAM;QACN,OAAO;IACT;IACA;QACE,IAAI,CAAA,GAAA,SAAK;QACT,MAAM;QACN,OAAO;IACT;IACA;QACE,IAAI,CAAA,GAAA,SAAK;QACT,MAAM;QACN,OAAO;IACT;IACA;QACE,IAAI,CAAA,GAAA,SAAK;QACT,MAAM;QACN,OAAO;IACT;IACA;QACE,IAAI,CAAA,GAAA,SAAK;QACT,MAAM;QACN,OAAO;IACT;IACA;QACE,IAAI,CAAA,GAAA,SAAK;QACT,MAAM;QACN,OAAO;IACT;IACA;QACE,IAAI,CAAA,GAAA,SAAK;QACT,MAAM;QACN,OAAO;IACT;IACA;QACE,IAAI,CAAA,GAAA,SAAK;QACT,MAAM;QACN,OAAO;IACT;CACD;;;AFvCM,MAAM,4CAA8B;IACzC,MAAM,CAAA,GAAA,yCAAc,EAAE,MAAM;IAC5B,YAAY;QACV,SAAS;YACP,MAAM,CAAA,GAAA,yCAAc,EAAE,KAAK;YAC3B,aAAa;YACb,WAAW;gBACT,MAAM,CAAA,GAAA,yCAAa,EAAE,IAAI;YAC3B;YACA,UAAU;QACZ;QACA,SAAS;YACP,MAAM,CAAA,GAAA,yCAAa,EAAE,IAAI;YACzB,aACE;YACF,cAAc;QAChB;IACF;AACF;AAEO,MAAM,4CAAc,CAAC;;AAE5B,CAAC;AAEM,MAAM,4CAAiB,CAAC;;;;;;;;;;;AAW/B,CAAC;AAEM,MAAM,4CAAe,CAAC;;AAE7B,CAAC;AAEM,MAAM,4CAA2B;IACtC,MAAM,CAAA,GAAA,yCAAa,EAAE,IAAI;AAC3B;AAEO,MAAM,4CAAwB;IACnC,IAAI,CAAA,GAAA,SAAK;IACT,UAAU,CAAA,GAAA,yCAAS,EAAE,IAAI,CAAC,CAAC,WAAa,SAAS,IAAI,KAAK,WAAW,MAAM;IAC3E,MAAM;IACN,OAAO;IACP,WAAW,KAAK,SAAS,CAAC;IAC1B,aAAa,0CAAY,IAAI;IAC7B,gBAAgB,0CAAe,IAAI;IACnC,cAAc,0CAAa,IAAI;IAC/B,QAAQ,KAAK,SAAS,CAAC;AACzB;;;;;AGnDO,MAAM,4CAAyB;IACpC,MAAM,CAAA,GAAA,yCAAc,EAAE,MAAM;IAC5B,YAAY;QACV,OAAO;YACL,MAAM,CAAA,GAAA,yCAAa,EAAE,KAAK;QAC5B;QACA,WAAW;YACT,MAAM,CAAA,GAAA,yCAAa,EAAE,IAAI;QAC3B;QACA,UAAU;YACR,MAAM,CAAA,GAAA,yCAAa,EAAE,IAAI;QAC3B;QACA,aAAa;YACX,MAAM,CAAA,GAAA,yCAAa,EAAE,IAAI;QAC3B;IACF;AACF;AAEO,MAAM,4CAAmB;IAC9B,IAAI,CAAA,GAAA,SAAK;IACT,MAAM;IACN,QAAQ,KAAK,SAAS,CAAC;AACzB;;;;;UE5BY;;;;;GAAA,8CAAA;;UAaA;;;;;;;;;;GAAA,8CAAA;;UAYA;;;GAAA,8CAAA;;UAYA;;;;GAAA,8CAAA;;UAyCA;;;;GAAA,8CAAA;;UAYA;;;;;GAAA,8CAAA;;UA0BC;;;;;GAAA,8CAAA;;UAkBD;;;;GAAA,8CAAA;;UAUA;;;;GAAA,8CAAA;;;;;;AEhJZ,yBAAyB;AACzB,oCAAoC;AACpC,8BAA8B;AAC9B,4CAA4C;AAE5C,oBAAoB;AACpB,MAAM,yCAAmB,eAEtB,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAS;AAEhC,4BAA4B;AAC5B,MAAM,4CAAsB,gBAAa,KAAK,CAAC;IAC7C,IAAI,gBAAa,QAAQ;IACzB,+CAA+C;IAC/C,mBAAmB;IACnB,aAAa;IACb,sBAAsB;IACtB,YAAY;IACZ,YAAY;IACZ,iBAAiB;IACjB,YAAY,gBAAa,QAAQ;IACjC,MAAM,uCAAiB,QAAQ;IAC/B,YAAY,gBAAa,QAAQ;AACnC;AAEA,uBAAuB;AACvB,MAAM,4CAAsB,0CACzB,MAAM,CAAC,cAAW;IACjB,MAAM,eAAY,KAAK,CAAC;QAAC,CAAA,GAAA,yCAAS,EAAE,OAAO;KAAC;AAC9C;AAEF,2BAA2B;AAC3B,MAAM,gDAA0B,0CAC7B,MAAM,CAAC,cAAW;IACjB,MAAM,eAAY,KAAK,CAAC;QAAC,CAAA,GAAA,yCAAS,EAAE,WAAW;KAAC;IAChD,WAAW,gBAAa,QAAQ;AAClC;AAEF,uBAAuB;AACvB,MAAM,4CAAsB,0CACzB,MAAM,CAAC,cAAW;IACjB,MAAM,eAAY,KAAK,CAAC;QAAC,CAAA,GAAA,yCAAS,EAAE,OAAO;KAAC;AAC9C;AAEF,yBAAyB;AACzB,MAAM,qCAAe,YAAS,CAAA;IAC5B,OAAQ,MAAM,IAAI;QAChB,KAAK,CAAA,GAAA,yCAAS,EAAE,OAAO;YACrB,OAAO;QACT,KAAK,CAAA,GAAA,yCAAS,EAAE,WAAW;YACzB,OAAO;QACT,KAAK,CAAA,GAAA,yCAAS,EAAE,OAAO;YACrB,OAAO;QACT;YACE,OAAO,gBAAa,KAAK,CAAC,CAAC;IAC/B;AACF;IAEA,2CAAe;;;;;;;AE1Df,yEAAyE;AACzE,MAAM,6CAAuB,eAA4B,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAa;AAC1F,MAAM,6CAAuB,eAA4B,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAa;AAC1F,MAAM,8CAAwB,eAA6B,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAc;AAC7F,MAAM,8CAAwB,eAA6B,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAc;AAE7F,mBAAmB;AACnB,MAAM,wCAAkB,YAAS,CAAA,QAC/B,eAAY,EAAE,CACZ,eAAY,KAAK,CAAC;QAChB;QACA;QACA;QACA;KACD,GACD,QAAQ;AAGZ,8BAA8B;AAC9B,MAAM,mCAAa,cAAW;IAC5B,MAAM;IACN,YAAY,YAAS,CAAC,QACpB,gBAAa,KAAK,CAChB,OAAO,IAAI,CAAC,OAAO,MAAM,CAAC,CAAC,OAAO;YAChC,KAAK,CAAC,IAAI,GAAG;YACb,OAAO;QACT,GAAG,CAAC,IACJ,QAAQ;IAEZ,WAAW,YAAS,IAAM,iCAAW,QAAQ;IAC7C,aAAa,gBAAa,QAAQ;IAClC,cAAc,eAAY,QAAQ;IAClC,UAAU,iBAAc,QAAQ;AAClC;IAEA,2CAAe;;;ADlCR,MAAM,4CAAe,gBAAa,KAAK,CAAC;IAC7C,MAAM,gBAAa,QAAQ;IAC3B,OAAO,gBAAa,QAAQ;IAC5B,MAAM,CAAA,GAAA,wCAAe,EAAE,QAAQ;IAC/B,UAAU,iBAAc,QAAQ;IAChC,cAAc,eAAY,QAAQ;AACpC;AAGO,MAAM,4CAAiB,eAE3B,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAO;AAGvB,MAAM,4CAAqB,eAE/B,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAW;AAG3B,MAAM,4CAA6B,eAEvC,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAmB;AAGnC,MAAM,4CAA6B,eAEvC,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAmB;AAGnC,MAAM,4CAAoB,gBAAa,KAAK,CAAC;IAClD,IAAI,gBAAa,QAAQ;IACzB,aAAa,eAAY,EAAE,CAAC,iBAAc,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,QAAQ;IAChE,MAAM,0CAAe,QAAQ;AAC/B;AAGO,MAAM,4CAAqB,0CAC/B,MAAM,CAAC,cAAW;IACjB,YAAY,0CAAmB,QAAQ;AACzC;AAGK,MAAM,4CAA6B,0CACvC,MAAM,CAAC,cAAW;IACjB,YAAY,eAAY,KAAK,CAAC;QAAC,CAAA,GAAA,yCAAW,EAAE,QAAQ;KAAC;IACrD,cAAc,gBAAa,QAAQ;AACrC;AAGK,MAAM,4CAA2B,0CACrC,MAAM,CAAC,cAAW;IACjB,YAAY,eAAY,KAAK,CAAC;QAAC,CAAA,GAAA,yCAAW,EAAE,MAAM;KAAC;IACnD,aAAa,0CAAa,QAAQ;AACpC;AAGK,MAAM,4CAA2B,0CACrC,MAAM,CAAC,cAAW;IACjB,YAAY,eAAY,KAAK,CAAC;QAAC,CAAA,GAAA,yCAAW,EAAE,MAAM;KAAC;IACnD,cAAc,gBAAa,QAAQ;AACrC;AAGK,MAAM,4CAA0B,0CACpC,MAAM,CAAC,cAAW;IACjB,YAAY,eAAY,KAAK,CAAC;QAAC,CAAA,GAAA,yCAAW,EAAE,KAAK;KAAC;IAClD,WAAW,gBAAa,QAAQ;IAChC,kCAAkC;IAClC,WAAW,0CAA2B,QAAQ;AAChD;AAGK,MAAM,4CAAmB,0CAC7B,MAAM,CAAC,cAAW;IACjB,QAAQ,eAAY,EAAE,CAAC,iBAAc,QAAQ;IAC7C,UAAU,gBAAa,QAAQ;IAC/B,OAAO,eAAY,EAAE,CAAC,iBAAc,QAAQ;AAC9C;AAGK,MAAM,4CAAmB,0CAC7B,MAAM,CAAC,cAAW;IACjB,YAAY,eAET,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAS,IAC7B,QAAQ;AACb;AAGK,MAAM,4CAAwB,0CAClC,MAAM,CAAC,cAAW;IACjB,YAAY,eAAY,KAAK,CAAC;QAAC,CAAA,GAAA,yCAAS,EAAE,KAAK;KAAC;IAChD,WAAW,gBAAa,QAAQ;IAChC,kCAAkC;IAClC,WAAW,0CAA2B,QAAQ;AAChD;AAEF,uBAAuB;AACvB,MAAM,mCAAa,YAAS,CAAA;IAC1B,OAAQ,MAAM,IAAI;QAChB,KAAK,CAAA,GAAA,yCAAO,EAAE,QAAQ;YACpB,OAAQ,MAAM,UAAU;gBACtB,KAAK,CAAA,GAAA,yCAAW,EAAE,QAAQ;oBACxB,OAAO;gBACT,KAAK,CAAA,GAAA,yCAAW,EAAE,MAAM;oBACtB,OAAO;gBACT,KAAK,CAAA,GAAA,yCAAW,EAAE,MAAM;oBACtB,OAAO;gBACT,KAAK,CAAA,GAAA,yCAAW,EAAE,KAAK;oBACrB,OAAO;gBACT;oBACE,OAAO;YACX;QACF,KAAK,CAAA,GAAA,yCAAO,EAAE,MAAM;YAClB,OAAO;QACT,KAAK,CAAA,GAAA,yCAAO,EAAE,MAAM;YAClB,OAAO,AAAC,MAAM,UAAU,KAAK,CAAA,GAAA,yCAAS,EAAE,KAAK,GAAI,4CAAwB;QAC3E;YACE,OAAO,gBAAa,KAAK,CAAC;gBACxB,MAAM,eAAsB,KAAK,CAAC,OAAO,MAAM,CAAC,CAAA,GAAA,yCAAO,IAAI,QAAQ;YACrE;IACJ;AACF;IAEA,2CAAe;;;AF5Hf,mBAAmB;AACnB,MAAM,wCAAkB,gBAAa,KAAK,CAAC;IACzC,IAAI,gBAAa,QAAQ;IACzB,MAAM,gBAAa,QAAQ;IAC3B,SAAS,eAAY,EAAE,CAAC,CAAA,GAAA,wCAAW,GAAG,QAAQ;IAC9C,OAAO,eAAY,EAAE,CAAC,CAAA,GAAA,wCAAS,GAAG,QAAQ;AAC5C;IAEA,2CAAe;;;;;;;AKZf,MAAM,8CAAwB,CAAC,MAAe;IAC5C,IAAI,CAAC,MACH,OAAO;IAGT,MAAM,UAAU,KAAK,KAAK,CAAC;IAC3B,IAAI,SACF,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,KAAK,CAAC;IAGpD,IAAI,IAAI,CAAC,EAAE,KAAK,KACd,OAAO,KAAK,KAAK,CAAC;IAGpB,IAAI,eAAe,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,aAC5C,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,KAAK,CAAC;IAGhD,OAAO;AACT;IAEA,2CAAe;;;ADIR,MAAM;IACX,+DAA+D;IAC/D,qDAAqD;IACrD,IAAI;IAEG,oBAAoB,MAAkB,EAAE,eAA2B,EAAW;QACnF,OAAO,IAAI,CAAC,4BAA4B,CAAC,QAAQ;IACnD;IAEO,oBACL,MAAkB,EAClB,MAAkB,EAClB,EAAsF,EAC7E;QACT,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,IAAI,CAAC,cAAc,CAAC,SACvD,MAAM,IAAI,MAAM;QAGlB,MAAM,iBAAiB;QAEvB,MAAM,UAAU,CAAA,GAAA,gBAAQ,EAAE;QAC1B,MAAM,UAAU,CAAA,GAAA,gBAAQ,EAAE;QAE1B,MAAM,oBAAmD,EAAE;QAC3D,MAAM,oBAAmD,OAAO,MAAM,CAAC,QAAQ,UAAU,IAAI,CAAC;QAE9F,IAAI,CAAC,8BAA8B,CAAC,SAAS,CAAC;YAC5C,kBAAkB,IAAI,CAAC;QACzB;QAEA,KAAK,MAAM,gBAAgB,kBACzB,KAAK,MAAM,gBAAgB,kBAAmB;YAC5C,IAAI,IAAI,CAAC,4BAA4B,CAAC;gBAAE,GAAG,YAAY;gBAAE,UAAU;YAAK,GAAG,eAAe;gBACxF,aAAa,aAAa,GAAG,aAAa,aAAa,IAAI,EAAE;gBAC7D,aAAa,aAAa,GAAG,aAAa,aAAa,IAAI,EAAE;gBAE7D,MAAM,OAAO,CAAA,GAAA,SAAK;gBAClB,MAAM,OAAO,CAAC,aAAa,QAAQ,IAAI,aAAa,QAAQ,GACxD,CAAA,GAAA,yCAAwB,EAAE,WAAW,GACrC,CAAA,GAAA,yCAAwB,EAAE,MAAM;gBAEpC,aAAa,aAAa,CAAC,IAAI,CAAC;oBAC9B,IAAI;oBACJ,MAAM,CAAA,GAAA,wCAAgB,EAAE,MAAM;0BAC9B;gBACF;gBACA,aAAa,aAAa,CAAC,IAAI,CAAC;oBAC9B,IAAI;oBACJ,MAAM,CAAA,GAAA,wCAAgB,EAAE,MAAM;0BAC9B;gBACF;YACF;YAEA,IACE,aAAa,IAAI,KAAK,CAAA,GAAA,yCAAc,EAAE,KAAK,IACxC,IAAI,CAAC,4BAA4B,CAAC,aAAa,SAAS,EAAG,eAC9D;gBACA,aAAa,aAAa,GAAG,aAAa,aAAa,IAAI,EAAE;gBAC7D,aAAa,aAAa,GAAG,aAAa,aAAa,IAAI,EAAE;gBAE7D,MAAM,OAAO,CAAA,GAAA,SAAK;gBAElB,aAAa,aAAa,CAAC,IAAI,CAAC;oBAC9B,IAAI;oBACJ,MAAM,CAAA,GAAA,wCAAgB,EAAE,MAAM;oBAC9B,MAAM,CAAA,GAAA,yCAAwB,EAAE,SAAS;gBAC3C;gBACA,aAAa,aAAa,CAAC,IAAI,CAAC;oBAC9B,IAAI;oBACJ,MAAM,CAAA,GAAA,wCAAgB,EAAE,MAAM;oBAC9B,MAAM,CAAA,GAAA,yCAAwB,EAAE,SAAS;gBAC3C;YACF;QACF;QAGF,OAAO;IACT;IAEA,sCAAsC;IACtC,4BAA4B;IAC5B,0BAA0B;IAC1B,4CAA4C;IAC5C,eAAe;IACf,0CAA0C;IAE1C,+EAA+E;IAC/E,wEAAwE;IACxE,oCAAoC;IACpC,QAAQ;IACR,QAAQ;IAER,yBAAyB;IAEzB,uCAAuC;IACvC,IAAI;IAEJ,gCAAgC;IAChC,4BAA4B;IAC5B,0BAA0B;IAC1B,mDAAmD;IACnD,eAAe;IACf,iDAAiD;IAEjD,iFAAiF;IACjF,iFAAiF;IACjF,8EAA8E;IAC9E,8GAA8G;IAC9G,UAAU;IAEV,aAAa;IACb,kCAAkC;IAClC,qCAAqC;IACrC,qGAAqG;IACrG,YAAY;IACZ,mHAAmH;IACnH,UAAU;IAEV,aAAa;IACb,uDAAuD;IACvD,yFAAyF;IACzF,YAAY;IACZ,iCAAiC;IACjC,wBAAwB;IACxB,qBAAqB;IACrB,kEAAkE;IAClE,cAAc;IACd,UAAU;IACV,UAAU;IACV,QAAQ;IAER,yBAAyB;IAEzB,uCAAuC;IACvC,IAAI;IAEG,eAAe,MAAkB,EAAW;QACjD,IAAI,OAAO,IAAI,KAAK,CAAA,GAAA,yCAAc,EAAE,MAAM,IAAI,OAAO,UAAU,EAC7D,OAAO;QAGT,OAAO;IACT;IAEO,+BACL,MAAkB,EAClB,QAA6C,EAC7C;QACA,OAAQ,OAAO,IAAI;YACjB,KAAK,CAAA,GAAA,yCAAa,EAAE,IAAI;YACxB,KAAK,CAAA,GAAA,yCAAa,EAAE,MAAM;YAC1B,KAAK,CAAA,GAAA,yCAAa,EAAE,IAAI;YACxB,KAAK,CAAA,GAAA,yCAAa,EAAE,KAAK;YACzB,KAAK,CAAA,GAAA,yCAAc,EAAE,IAAI;YACzB,KAAK,CAAA,GAAA,yCAAc,EAAE,KAAK;YAC1B,KAAK,CAAA,GAAA,yCAAc,EAAE,KAAK;YAC1B,KAAK,CAAA,GAAA,yCAAc,EAAE,KAAK;YAC1B,KAAK,CAAA,GAAA,yCAAc,EAAE,GAAG;gBACtB,SAAS;gBACT;YACF,KAAK,CAAA,GAAA,yCAAc,EAAE,MAAM;gBACzB,OAAO,OAAO,CAAC,OAAO,UAAU,IAAI,CAAC,GAAG,OAAO,CAC7C,CAAC,CAAC,KAAK,MAA4B;oBACjC,IAAI,CAAC,8BAA8B,CACjC,OACA,CAAC;wBACC,SAAS;oBACX;gBAEJ;gBAEF;YACF,KAAK,CAAA,GAAA,yCAAc,EAAE,KAAK;gBACxB,IAAI,CAAC,8BAA8B,CACjC,OAAO,SAAS,EAChB,CAAC;oBACC,SAAS;gBACX;gBAEF;YACF;gBACE,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,OAAO,IAAI,CAAC,CAAC;QAC3D;IACF;IAEO,kBAAkB,MAAkB,EAAE,IAAY,EAAc;QACrE,MAAM,YAAY,CAAA,GAAA,wCAAoB,EAAE,MACrC,OAAO,CAAC,aAAa,IACrB,KAAK,CAAC,KACN,MAAM,CAAC,CAAC,OAAS,SAAS;QAE7B,IAAI,gBAAgB;QAEpB,KAAK,MAAM,YAAY,UACrB,OAAQ,cAAc,IAAI;YACxB,KAAK,CAAA,GAAA,yCAAc,EAAE,MAAM;gBACzB,gBAAgB,cAAc,UAAU,AAAC,CAAC,SAAS;gBACnD;YACF,KAAK,CAAA,GAAA,yCAAc,EAAE,KAAK;gBACxB,gBAAgB,cAAc,SAAS;gBACvC;YACF;gBACE,MAAM,IAAI,MACR,CAAC,uBAAuB,EAAE,cAAc,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC;QAErE;QAGF,OAAO;IACT;IAEQ,6BACN,UAAsB,EACtB,QAAoB,EACX;QACT,IAAI,WAAW,IAAI,KAAK,SAAS,IAAI,EACnC,OAAO;QAGT,OAAQ,WAAW,IAAI;YACrB,KAAK,CAAA,GAAA,yCAAa,EAAE,IAAI;YACxB,KAAK,CAAA,GAAA,yCAAa,EAAE,MAAM;YAC1B,KAAK,CAAA,GAAA,yCAAa,EAAE,IAAI;YACxB,KAAK,CAAA,GAAA,yCAAa,EAAE,KAAK;YACzB,KAAK,CAAA,GAAA,yCAAc,EAAE,IAAI;YACzB,KAAK,CAAA,GAAA,yCAAc,EAAE,KAAK;YAC1B,KAAK,CAAA,GAAA,yCAAc,EAAE,KAAK;YAC1B,KAAK,CAAA,GAAA,yCAAc,EAAE,KAAK;gBACxB,OAAO,WAAW,QAAQ,KAAK,SAAS,QAAQ,IAAI,CAAC,SAAS,QAAQ;YACxE,KAAK,CAAA,GAAA,yCAAc,EAAE,MAAM;gBACzB,OAAO,OAAO,OAAO,CAAC,WAAW,UAAU,IAAI,CAAC,GAAG,KAAK,CACtD,CAAC,CAAC,KAAK,MAAM;oBACX,MAAM,mBAAmB,SAAS,UAAU,EAAE,CAAC,IAAI;oBACnD,IAAI,CAAC,kBACH,OAAO;oBAET,OAAO,IAAI,CAAC,4BAA4B,CAAC,OAAO;gBAClD;YAEJ,KAAK,CAAA,GAAA,yCAAc,EAAE,KAAK;gBACxB,OAAO,IAAI,CAAC,4BAA4B,CACtC,WAAW,SAAS,EACpB,SAAS,SAAS;YAEtB;gBACE,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,WAAW,IAAI,CAAC,CAAC;QAC/D;IACF;AAuBF;;;;AN9QO,MAAM;IAOX,YACE,SAA2B,EAC3B,AAAmB,MAAe,EAClC,OAEC,CACD;aAJmB,SAAA;aARF,oBAAuC,IAAI,CAAA,GAAA,yCAAgB;aACpE,YAAuB,0CAAiB,cAAc;aACtD,cAAkC,EAAE;aACpC,cAA2B,EAAE;aAC7B,cAA2B,EAAE;QASrC,IAAI,WAAW;YACb,IAAI,CAAC,SAAS,GAAG;YAEjB,IAAI,CAAC,SAAS,gBAAgB;gBAC5B,MAAM,WAAE,OAAO,EAAE,GAAG,IAAI,CAAC,cAAc;gBACvC,IAAI,CAAC,SACH,MAAM,IAAI,MAAM;YAEpB;QACF,OACE,IAAI,CAAC,oBAAoB;IAE7B;IAEA,4EAA4E;IAC5E,IAAI,mBAA8B;QAChC,OAAO,IAAI,CAAC,SAAS;IACvB;IAEA,WAAW,iBAA4B;QACrC,OAAO;YACL,IAAI,CAAA,GAAA,SAAK;YACT,MAAM;YACN,OAAO,EAAE;YACT,SAAS,EAAE;QACb;IACF;IAEO,qBAAqB,SAAoB,EAAa;QAC3D,IAAI,CAAC,SAAS,GAAG;QAEjB,OAAO,IAAI,CAAC,SAAS;IACvB;IAEA,mBAAmB;IACZ,qBAAqB,MAAc,EAAW;QACnD,MAAM,IAAI,MAAM;IAClB;IAEA;;;;;;;;;;;GAWC,GACD,AAAO,qBAAqB,IAAa,EAAa;QACpD,IAAI,CAAC,yBAAyB;QAE9B,IAAI,CAAC,SAAS,GAAG;YACf,IAAI,CAAA,GAAA,SAAK;YACT,MAAM,QAAQ;YACd,OAAO,EAAE;YACT,SAAS,EAAE;QACb;QAEA,OAAO,IAAI,CAAC,SAAS;IACvB;IAEA;;;;;;GAMC,GACD,AAAO,gBAAgB,IAAY,EAAa;QAC9C,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG;QACtB,OAAO,IAAI,CAAC,SAAS;IACvB;IAEA;;;;;;;;;;;GAWC,GACD,AAAO,iBAAsD;QAC3D,IAAI;YACF,CAAA,GAAA,wCAAc,EAAE,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE;gBAC3C,YAAY;YACd;YAEA,OAAO;gBACL,SAAS;gBACT,QAAQ,EAAE;YACZ;QACF,EAAE,OAAO,GAAQ;YACf,OAAO;gBACL,SAAS;gBACT,QAAQ,EAAE,MAAM;YAClB;QACF;IACF;IAEA;;;;;;;;;;;;;;GAcC,GACD,AAAO,wBACL,IAAkB,EACN;QACZ,MAAM,SAAS,KAAK,UAAU;QAC9B,MAAM,aAAa,MAAM,CAAC,EAAE;QAC5B,MAAM,WAAW,MAAM,CAAC,EAAE;QAE1B,OAAQ,KAAK,UAAU;YACrB,KAAK,CAAA,GAAA,yCAAW,EAAE,MAAM;gBACtB,OAAO,IAAI,CAAC,eAAe,CAAC;YAC9B,KAAK,CAAA,GAAA,yCAAW,EAAE,KAAK;gBAAE;oBACvB,MAAM,cAAc,IAAI,CAAC,cAAc,CAAC;oBAExC,IAAI,AAAC,KAA2B,SAAS,KAAK,CAAA,GAAA,yCAAmB,EAAE,QAAQ,EACzE,OAAO;wBACL,MAAM,CAAA,GAAA,yCAAc,EAAE,KAAK;wBAC3B,WAAW;oBACb;oBAGF,OAAO;gBACT;YACA,KAAK,CAAA,GAAA,yCAAW,EAAE,QAAQ;gBACxB,MAAM,IAAI,MAAM;YAClB,KAAK,CAAA,GAAA,yCAAW,EAAE,MAAM;gBACtB,OAAO,AAAC,KAA4B,WAAW,CAAC,IAAI;YACtD;gBACE,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,WAAW,CAAC;QACjE;IACF;IAEA;;;;;;;;;;;;GAYC,GACD,AAAO,aAAa,IAAU,EAAW;QACvC,IAAI,IAAI,CAAC,cAAc,CAAC,KAAK,WAAW,GACtC,MAAM,IAAI,MAAM;QAGlB,OAAQ,KAAK,IAAI;YACf,KAAK,CAAA,GAAA,yCAAO,EAAE,QAAQ;gBACpB,CAAA,GAAA,yCAAiB,EAAE,QAAQ,CAAC,MAAM;oBAChC,YAAY;gBACd;gBACA;YACF,KAAK,CAAA,GAAA,yCAAO,EAAE,MAAM;gBAClB,CAAA,GAAA,yCAAe,EAAE,QAAQ,CAAC,MAAM;oBAC9B,YAAY;gBACd;gBACA;YACF,KAAK,CAAA,GAAA,yCAAO,EAAE,MAAM;gBAClB,CAAA,GAAA,yCAAe,EAAE,QAAQ,CAAC,MAAM;oBAC9B,YAAY;gBACd;gBACA;YACF;gBACE,MAAM,IAAI,MAAM,CAAC,mBAAmB,EAAE,KAAK,IAAI,CAAC,CAAC;QACrD;QAEA,OAAO;IACT;IAEA;;;;;;;;;;GAUC,GACD,AAAO,QAAQ,IAAU,EAAE,aAAgC,EAAa;QACtE,IAAI,CAAC,YAAY,CAAC;QAElB,sCAAsC;QACtC,IAAI,KAAK,IAAI,KAAK,CAAA,GAAA,yCAAO,EAAE,MAAM,EAAE;YACjC,IAAI,CAAC,eACH,MAAM,IAAI,MAAM;YAGlB,IAAI,AAAC,KAAoB,QAAQ,KAAK,cAAc,QAAQ,EAC1D,MAAM,IAAI,MAAM;YAGlB,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,aAAe,WAAW,QAAQ,KAAK,cAAc,QAAQ,GACvF,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;QAE1B;QAEA,IAAI,CAAC,YAAY,CAAC;YAChB,GAAG,IAAI,CAAC,SAAS;YACjB,OAAO;mBAAI,IAAI,CAAC,SAAS,CAAC,KAAK;gBAAE;aAAK;QACxC;QAEA,OAAO,IAAI,CAAC,SAAS;IACvB;IAEA;;;;;;;;;;;;GAYC,GACD,AAAO,WAAW,EAAU,EAAa;QACvC,MAAM,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAY,EAAE,EAAE,KAAK;QAE7D,IAAI,CAAC,MACH,MAAM,IAAI,MAAM,CAAC,KAAK,EAAE,GAAG,UAAU,CAAC;QAGxC,0CAA0C;QAC1C,MAAM,aAAa,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,YAAY,KAAK,MAAM,EAAE,WAAW,KAAK;QAEnG,OAAO,IAAI,CAAC,YAAY,CAAC;YACvB,GAAG,IAAI,CAAC,SAAS;YACjB,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK;YACnD,SAAS;QACX;IACF;IAEA;;;;;;;;;;;;;;;GAeC,GACD,AAAO,gBACL,UAAkB,EAClB,QAAgB,EAChB,EAAoD,EAC3C;QACT,MAAM,WAAW,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CACxC,CAAC,IAAY,EAAE,EAAE,KAAK;QAExB,MAAM,SAAS,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAY,EAAE,EAAE,KAAK;QAE/D,IAAI,WAA8B;QAElC,IAAI,QAAQ,SAAS,CAAA,GAAA,yCAAO,EAAE,MAAM,EAClC,WAAW,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE;QAG3C,IAAI,QAAQ,SAAS,CAAA,GAAA,yCAAO,EAAE,MAAM,EAClC,WAAW,IAAI,CAAC,wBAAwB,CACtC,AAAC,OAAsB,QAAQ;QAInC,IAAI,CAAC,UACH,OAAO;QAGT,MAAM,aAAa,IAAI,CAAC,mBAAmB,CAAC;QAE5C,OAAO,IAAI,CAAC,iBAAiB,CAAC,mBAAmB,CAC/C,YACA,UACA,CAAC,QAAQ,SAAW,GAAG;gBACrB,MAAM;gBACN,IAAI;YACN;IAEJ;IAEA;;;;;;;;;;;;;;;;GAgBC,GACD,AAAO,UACL,MAA0B,EACf;QACX,8BAA8B;QAE9B,MAAM,WAAW,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CACxC,CAAC,IAAY,EAAE,EAAE,KAAK,OAAO,YAAY;QAG3C,IAAI,CAAC,UACH,MAAM,IAAI,MAAM,CAAC,KAAK,EAAE,OAAO,YAAY,CAAC,UAAU,CAAC;QAGzD,MAAM,SAAS,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAY,EAAE,EAAE,KAAK,OAAO,WAAW;QAEjF,IAAI,CAAC,QACH,MAAM,IAAI,MAAM,CAAC,KAAK,EAAE,OAAO,WAAW,CAAC,UAAU,CAAC;QAGxD,oBAAoB;QACpB,IAAI;QACJ,OAAO;QACP,gFAAgF;QAChF,+BAA+B;QAC/B,OAAO;QACP,MAAM;QACN,kGAAkG;QAClG,IAAI;QAEJ,yBAAyB;QACzB,+IAA+I;QAC/I,qEAAqE;QACrE,IAAI;QAEJ,MAAM,WAAW,CAAA,GAAA,SAAK;QAEtB,IAAI,CAAC,YAAY,CAAC;YAChB,GAAG,IAAI,CAAC,SAAS;YACjB,SAAS;mBACJ,IAAI,CAAC,SAAS,CAAC,OAAO;gBACzB;oBACE,GAAG,MAAM;oBACT,IAAI;gBACN;aACD;QACH;QAEA,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC;YAC1B,GAAG,MAAM;YACT,IAAI;QACN;QAEA,OAAO,IAAI,CAAC,SAAS;IACvB;IAEA;;;;;;;;;;;;;;;GAeC,GACD,+CAA+C;IAC/C,gFAAgF;IAEhF,wBAAwB;IACxB,iDAAiD;IACjD,MAAM;IAEN,6CAA6C;IAE7C,gCAAgC;IAChC,sEAAsE;IACtE,oCAAoC;IAEpC,2BAA2B;IAC3B,gCAAgC;IAChC,gDAAgD;IAChD,iCAAiC;IACjC,kEAAkE;IAClE,iBAAiB;IACjB,8BAA8B;IAC9B,8EAA8E;IAC9E,mDAAmD;IACnD,aAAa;IACb,gFAAgF;IAChF,mDAAmD;IACnD,aAAa;IACb,iBAAiB;IACjB,8BAA8B;IAC9B,8EAA8E;IAC9E,mDAAmD;IACnD,aAAa;IACb,iBAAiB;IACjB,iBAAiB;IACjB,8DAA8D;IAC9D,QAAQ;IAER,mBAAmB;IACnB,QAAQ;IAER,2BAA2B;IAC3B,IAAI;IAEJ;;;;;;;;;;;;GAYC,GACD,AAAO,sBACL,EAAU,EACV,QAA0B,EACf;QACX,MAAM,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAY,EAAE,EAAE,KAAK;QAE7D,IAAI,CAAC,MACH,MAAM,IAAI,MAAM,CAAC,KAAK,EAAE,GAAG,UAAU,CAAC;QAGxC,MAAM,wBAAwB,IAAI,CAAC,cAAc,CAAC;QAElD,IAAI,uBACF,MAAM,IAAI,MAAM;QAGlB,OAAO,IAAI,CAAC,YAAY,CAAC;YACvB,GAAG,IAAI,CAAC,SAAS;YACjB,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;gBAC/B,IAAI,EAAE,EAAE,KAAK,IACX,OAAO;oBACL,GAAG,CAAC;oBACJ,aAAa;gBACf;gBAGF,OAAO;YACT;QACF;IACF;IAEA;;;;;;;;;GASC,GACD,AAAO,eAAe,QAA0B,EAAW;QACzD,OAAO,QAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAY,EAAE,WAAW,CAAC,EAAE,KAAK,QAAQ,CAAC,EAAE,IAAI,EAAE,WAAW,CAAC,EAAE,KAAK,QAAQ,CAAC,EAAE;IAC5H;IAEA;;;;;;;;;;;;;GAaC,GACD,AAAO,oBAAoB,IAAU,EAAc;QACjD,OAAQ,KAAK,IAAI;YACf,KAAK,CAAA,GAAA,yCAAO,EAAE,QAAQ;gBACpB,OAAO,IAAI,CAAC,uBAAuB,CAAC;YACtC,KAAK,CAAA,GAAA,yCAAO,EAAE,MAAM;gBAClB,OAAO,IAAI,CAAC,qBAAqB,CAAC,AAAC,KAAoB,QAAQ;YACjE,KAAK,CAAA,GAAA,yCAAO,EAAE,MAAM;gBAClB,OAAO,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE;YACrC;gBACE,MAAM,IAAI,MAAM,CAAC,mBAAmB,EAAE,KAAK,IAAI,CAAC,CAAC;QACrD;IACF;IAEA;;;;;;;;;;;GAWC,GACD,AAAO,yBAAyB,QAAgB,EAAc;QAC5D,MAAM,SAAS,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,IAAM,EAAE,QAAQ,KAAK;QAE3D,IAAI,CAAC,QACH,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,SAAS,UAAU,CAAC;QAGhD,OAAO,OAAO,SAAS;IACzB;IAEO,OAAkB;QACvB,OAAO,IAAI,CAAC,qBAAqB;IACnC;IAEO,OAAkB;QACvB,OAAO,IAAI,CAAC,mBAAmB;IACjC;IAEO,eAAe,MAAc,EAAY;QAC9C,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,YAAY,KAAK;IACjE;IAEO,cAAc,MAAc,EAAY;QAC7C,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAM,EAAE,WAAW,KAAK;IAChE;IAEA,8EAA8E;IACpE,uBAAuB,MAAc,EAAc;QAC3D,MAAM,SAAS,IAAI,CAAC,aAAa,CAAC;QAElC,IAAI,CAAC,QACH,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,OAAO,UAAU,CAAC;QAG9C,IAAI,OAAO,UAAU,KAAK,CAAA,GAAA,yCAAS,EAAE,KAAK,EACxC,OAAO,IAAI,CAAC,cAAc,CAAC,AAAC,OAA2B,SAAS;QAGlE,MAAM,sBAAkC;YACtC,MAAM,CAAA,GAAA,yCAAc,EAAE,MAAM;YAC5B,YAAY,AAAC,OAA8B,UAAU,CAAC,MAAM,CAAC,CAAC,KAAK;gBACjE,GAAG,CAAC,KAAK,GAAG;oBACV,MAAM,CAAA,GAAA,yCAAc,EAAE,GAAG;oBACzB,UAAU;gBACZ;gBAEA,OAAO;YACT,GAAG,CAAC;YACJ,UAAU;QACZ;QAEA,OAAO;IACT;IAEU,aAAa,SAAoB,EAAa;QACtD,IAAI,CAAC,gBAAgB;QAErB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS;QACpC,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,IAC5B,IAAI,CAAC,WAAW,CAAC,KAAK;QAGxB,IAAI,CAAC,SAAS,GAAG;QAEjB,OAAO;IACT;IAEU,wBAAmC;QAC3C,IAAI,CAAC,uBAAuB;QAE5B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,MAAM,IAAI,CAAC,SAAS;QAEzD,OAAO,IAAI,CAAC,SAAS;IACvB;IAEU,0BAAqC;QAC7C,IAAI,CAAC,IAAI,CAAC,SAAS,EACjB,OAAO,IAAI,CAAC,SAAS;QAGvB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS;QACpC,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,IAC5B,IAAI,CAAC,WAAW,CAAC,KAAK;QAGxB,OAAO,IAAI,CAAC,SAAS;IACvB;IAEU,4BAAuC;QAC/C,IAAI,CAAC,IAAI,CAAC,SAAS,EACjB,OAAO,IAAI,CAAC,SAAS;QAGvB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS;QACpC,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,IAC5B,IAAI,CAAC,WAAW,CAAC,KAAK;QAGxB,OAAO,IAAI,CAAC,SAAS;IACvB;IAEU,mBAA8B;QACtC,IAAI,CAAC,WAAW,GAAG,EAAE;QACrB,OAAO,IAAI,CAAC,SAAS;IACvB;IAEU,sBAAiC;QACzC,IAAI,CAAC,yBAAyB;QAE9B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,MAAM,IAAI,CAAC,SAAS;QAEzD,OAAO,IAAI,CAAC,SAAS;IACvB;IAEU,sBAAsB,QAAgB,EAAc;QAC5D,MAAM,SAAS,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,IAAM,EAAE,QAAQ,KAAK;QAE3D,IAAI,CAAC,QACH,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,SAAS,UAAU,CAAC;QAGhD,OAAO,OAAO,MAAM;IACtB;IAEU,eAAe,SAAiB,EAAc;QACtD,MAAM,QAAQ,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAa,EAAE,IAAI,KAAK;QAExD,IAAI,CAAC,OACH,MAAM,IAAI,MAAM,CAAC,MAAM,EAAE,UAAU,UAAU,CAAC;QAGhD,OAAO,KAAK,KAAK,CAAC,MAAM,MAAM;IAChC;IAEU,cAAc,EAAU,EAAqB;QACrD,OAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAC/B,CAAC,OAAe,KAAK,IAAI,KAAK,CAAA,GAAA,yCAAO,EAAE,MAAM,IAAI,KAAK,EAAE,KAAK,OAC1D;IACP;IAEU,gBAAgB,EAAU,EAAc;QAChD,oEAAoE;QACpE,MAAM,SAAS,IAAI,CAAC,aAAa,CAAC;QAClC,IAAI,CAAC,QACH,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,GAAG,UAAU,CAAC;QAG1C,4DAA4D;QAC5D,MAAM,YAAY,IAAI,CAAC,wBAAwB,CAAC,OAAO,EAAE;QAEzD,OAAO,IAAI,CAAC,mBAAmB,CAAC;IAClC;IAEA;;;;;;;;;;;;;;;;;;;;;;;;GAwBC,GACD,AAAU,oBACR,SAAmB,EACP;QACZ,MAAM,aAAa;YACjB,MAAM,CAAA,GAAA,yCAAc,EAAE,MAAM;YAC5B,YAAY,CAAC;YACb,UAAU;QACZ;QAEA,UAAU,OAAO,CAAC,CAAC;YACjB,MAAM,aAAa,IAAI,CAAC,sBAAsB,CAAC,OAAO,EAAE;YAExD,MAAM,yBAAyB,IAAI,CAAC,mBAAmB,CAAC;YAExD,OAAO,OAAO,CAAC,OAAO,CAAC,CAAC;gBACtB,MAAM,eAAe,IAAI,CAAC,iBAAiB,CAAC,iBAAiB,CAC3D,wBACA,QAAQ,UAAU;gBAGpB,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,eACzC,MAAM,IAAI,MACR,CAAC,aAAa,EAAE,QAAQ,UAAU,CAAC,mBAAmB,EAAE,WAAW,EAAE,CAAC,CAAC;gBAI3E,WAAW,UAAU,AAAC,CAAC,QAAQ,SAAS,CAAC,GAAG;YAC9C;QACF;QAEA,OAAO;IACT;IAEU,cAAc,EAAU,EAAU;QAC1C,MAAM,SAAS,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,IAAc,EAAE,EAAE,KAAK;QAEnE,IAAI,CAAC,QACH,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,GAAG,UAAU,CAAC;QAG1C,OAAO;IACT;IAEU,gBAAgB,GAAa,EAAY;QACjD,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAc,IAAI,QAAQ,CAAC,EAAE,EAAE;IACvE;IAEU,yBAAyB,EAAU,EAAY;QACvD,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAc,EAAE,YAAY,KAAK;IACzE;IAEU,uBAAuB,QAAgB,EAAQ;QACvD,MAAM,SAAS,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,IAAc,EAAE,EAAE,KAAK;QACnE,IAAI,CAAC,QACH,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,SAAS,UAAU,CAAC;QAGhD,MAAM,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAY,EAAE,EAAE,KAAK,QAAQ;QACrE,IAAI,CAAC,MACH,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,SAAS,UAAU,CAAC;QAGzD,OAAO;IACT;AACF;","sources":["src/index.ts","src/action/definitions/combine.ts","src/dataSchema/types/dataSchema.ts","src/action/categories.ts","src/model/definitions/user.ts","src/actionMap/actionMapHandler.ts","src/actionMap/types/actionMap.ts","src/actionMap/schema/actionMap.schema.ts","src/actionMap/schema/output.schema.ts","src/actionMap/schema/tile.schema.ts","src/dataSchema/schema/dataSchema.schema.ts","src/dataSchema/dataSchema.ts","src/actionMap/helpers/pathValidateAndFormat.ts"],"sourcesContent":["import { combineAction } from './action/definitions/combine';\nimport { userModel } from './model/definitions/user';\nimport { ActionMapHandler } from './actionMap/actionMapHandler';\nimport { DataSchemaHandler } from './dataSchema/dataSchema';\nimport type { Model } from './model/types/model'\nimport {\n    AccessorTile,\n    ActionMap,\n    ActionTile,\n    ConditionalOutput,\n    DataIn,\n    ConditionOperator,\n    DefaultOutput,\n    ForEachOutput,\n    MemoryTile,\n    Output,\n    OutputGeneral,\n    OutputType,\n    Tile,\n    TileType,\n    AccessorType,\n    MemoryType,\n    ModelAccessOperation,\n} from './actionMap/types/actionMap';\nimport {\n    ComplexDataType,ContentDataType,DataSchema,DataTypes,FormatDataType,SimpleDataType\n} from './dataSchema/types/dataSchema';\n\nexport {\n    TileType,\n    OutputType,\n    ConditionOperator,\n    SimpleDataType,\n    FormatDataType,\n    ActionMapHandler,\n    DataSchemaHandler,\n    ComplexDataType,\n    ContentDataType,\n    AccessorType,\n    MemoryType,\n    userModel as UserModel,\n    combineAction as CombineAction,\n    ModelAccessOperation,\n}\nexport type {\n    Tile,\n    OutputGeneral,\n    Output,\n    MemoryTile,\n    ForEachOutput,\n    DefaultOutput,\n    DataIn,\n    ConditionalOutput,\n    ActionTile,\n    AccessorTile,\n    DataTypes,\n    DataSchema,\n    Model,\n    ActionMap,\n}","import { v4 as uuidv4 } from 'uuid';\nimport { ComplexDataType, DataSchema, SimpleDataType } from \"../../dataSchema/types/dataSchema\";\nimport { Action } from '../types/action';\nimport { categories } from '../categories';\n\nexport const actionArguments: DataSchema = {\n  type: ComplexDataType.Object,\n  properties: {\n    strings: {\n      type: ComplexDataType.Array,\n      description: 'An array of strings to be concatenated.',\n      arrayType: {\n        type: SimpleDataType.Text,\n      },\n      required: true,\n    },\n    divider: {\n      type: SimpleDataType.Text,\n      description:\n        'The divider to be used between strings. Default is a space.',\n      defaultValue: ' ',\n    },\n  },\n};\n\nexport const description = `\nConcatenates an array of strings into a single string.\n`;\n\nexport const implementation = `\nconst concat = (strings, divider = ' ') => {\n  const validate = ajv.compile($actionArguments$);\n  const valid = validate({ strings, divider });\n\n  if (!valid) {\n    throw new Error(\\`Invalid arguments for action $actionName$: \\${ajv.errorsText(validate.errors)}\\`);\n  }\n\n  return strings.join(divider);\n}\n`;\n\nexport const functionCall = `\nconst $variable$ = concat($strings$, $divider$);\n`;\n\nexport const actionOutput: DataSchema = {\n  type: SimpleDataType.Text,\n};\n\nexport const combineAction: Action = {\n  id: uuidv4(),\n  category: categories.find((category) => category.name === 'string')?.id || '',\n  name: 'combine',\n  label: 'Combine',\n  arguments: JSON.stringify(actionArguments),\n  description: description.trim(),\n  implementation: implementation.trim(),\n  functionCall: functionCall.trim(),\n  output: JSON.stringify(actionOutput),\n};\n","export enum SimpleDataType {\n  Text = 'text',\n  Number = 'number',\n  Date = 'date',\n  YesNo = 'yesNo',\n}\n\nexport enum FormatDataType {\n  Money = 'money',\n  PhoneNumber = 'phoneNumber',\n  Email = 'email',\n  Url = 'url',\n}\n\nexport enum ContentDataType {\n  Image = 'image',\n  Video = 'video',\n  Audio = 'audio',\n  File = 'file',\n}\n\nexport enum ComplexDataType {\n  Object = 'object',\n  Array = 'array',\n}\n\nexport enum SpecialDataType {\n  Any = 'any',\n}\n\nexport type DataTypes = SimpleDataType | ComplexDataType | FormatDataType | ContentDataType | SpecialDataType;\n\nexport type DataSchema = {\n  type: DataTypes; // | DataTypes[];\n  properties?: {\n    [key: string]: DataSchema;\n  }\n  arrayType?: DataSchema;\n  description?: string;\n  defaultValue?: any;\n  required?: boolean;\n};\n\n\n// Data schema compatibility ----------------------------------------------------\nexport enum CompatibilitySide {\n  Source = 'source',\n  Target = 'target',\n}\n\nexport enum SchemasCompatibilityTypes {\n  Direct = 'direct', // compatible\n  Conditional = 'conditional', // need to check value existence\n  ArrayItem = 'arrayItem', // can use with array item, need to check value existence\n}\n\nexport type Compatibility = {\n  id: string;\n  side: CompatibilitySide;\n  type: SchemasCompatibilityTypes;\n}\n\nexport type DataSchemaWithCompatibility = DataSchema & {\n  properties?: {\n    [key: string]: DataSchemaWithCompatibility;\n  }\n  compatibility?: Compatibility[];\n}\n","import { v4 as uuidv4 } from 'uuid';\nimport { Category } from './types/category';\n\nexport const categories: Category[] = [\n  {\n    id: uuidv4(),\n    name: 'string',\n    label: 'String',\n  },\n  {\n    id: uuidv4(),\n    name: 'array',\n    label: 'Array',\n  },\n  {\n    id: uuidv4(),\n    name: 'object',\n    label: 'Object',\n  },\n  {\n    id: uuidv4(),\n    name: 'math',\n    label: 'Math',\n  },\n  {\n    id: uuidv4(),\n    name: 'date',\n    label: 'Date',\n  },\n  {\n    id: uuidv4(),\n    name: 'url',\n    label: 'URL',\n  },\n  {\n    id: uuidv4(),\n    name: 'json',\n    label: 'JSON',\n  },\n  {\n    id: uuidv4(),\n    name: 'utility',\n    label: 'Utility',\n  },\n];\n","import { v4 as uuidv4 } from 'uuid';\nimport {\n  ComplexDataType,\n  DataSchema,\n  FormatDataType,\n  SimpleDataType,\n} from \"../../dataSchema/types/dataSchema\";\nimport { Model } from '../types/model';\n\nexport const userSchema: DataSchema = {\n  type: ComplexDataType.Object,\n  properties: {\n    email: {\n      type: FormatDataType.Email,\n    },\n    firstName: {\n      type: SimpleDataType.Text,\n    },\n    lastName: {\n      type: SimpleDataType.Text,\n    },\n    dateOfBirth: {\n      type: SimpleDataType.Date,\n    },\n  },\n};\n\nexport const userModel: Model = {\n  id: uuidv4(),\n  name: 'user',\n  schema: JSON.stringify(userSchema),\n};\n","import { v4 as uuidv4 } from 'uuid';\nimport {\n  ActionMap,\n  AccessorTile,\n  ActionTile,\n  MemoryTile,\n  Tile,\n  TileType,\n  Output,\n  AccessorType,\n  ModelAccessorTile,\n  ModelAccessOperation,\n  DataInAccessorTile,\n  ActionDataSchema,\n  OutputCompatiblePaths,\n  MemoryType,\n  ModelMemoryTile,\n  InternalMemoryTile,\n} from './types/actionMap';\nimport actionMapSchema from './schema/actionMap.schema';\nimport { Model } from '../model/types/model';\nimport { ComplexDataType, DataSchema, SpecialDataType } from '../dataSchema/types/dataSchema';\nimport { DataSchemaHandler } from '../dataSchema/dataSchema';\nimport { accessorTileSchema, actionTileSchema, memoryTileSchema } from './schema/tile.schema';\n\nexport class ActionMapHandler {\n  protected readonly dataSchemaHandler: DataSchemaHandler = new DataSchemaHandler();\n  protected actionMap: ActionMap = ActionMapHandler.emptyActionMap;\n  protected usedActions: ActionDataSchema[] = []; // \n  protected changeStack: ActionMap[] = []; // TODO: optimize\n  protected futureStack: ActionMap[] = [];\n\n  constructor(\n    actionMap: ActionMap | null,\n    protected readonly models: Model[],\n    options?: {\n      skipValidation?: boolean;\n    }\n  ) {\n    if (actionMap) {\n      this.actionMap = actionMap;\n\n      if (!options?.skipValidation) {\n        const { isValid } = this.validateSchema();\n        if (!isValid) {\n          throw new Error('Invalid action map schema');\n        }\n      }\n    } else {\n      this.createEmptyActionMap();\n    }\n  }\n\n  // PUBLIC ------------------------------------------------------------------\n  get currentActionMap(): ActionMap {\n    return this.actionMap;\n  }\n\n  static get emptyActionMap(): ActionMap {\n    return {\n      id: uuidv4(),\n      name: 'New Action Map',\n      tiles: [],\n      outputs: [],\n    };\n  }\n\n  public forceUpdateActionMap(actionMap: ActionMap): ActionMap {\n    this.actionMap = actionMap;\n\n    return this.actionMap;\n  }\n\n  // TODO: implement!\n  public isTileNeedsForInputs(tileId: string): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Creates an empty ActionMap with a unique ID and optional name.\n   * If no name is provided, the default name 'New Action Map' is used.\n   * The function initializes empty arrays for tiles and outputs.\n   *\n   * @param {string} [name] - Optional name for the ActionMap. Defaults to 'New Action Map'.\n   * @returns {ActionMap} An object representing the new ActionMap with the following properties:\n   *                       - id: a unique identifier generated by uuidv4.\n   *                       - name: the name of the ActionMap.\n   *                       - tiles: an empty array of tiles.\n   *                       - outputs: an empty array of outputs.\n   */\n  public createEmptyActionMap(name?: string): ActionMap {\n    this.putCurrentToPreviousState();\n\n    this.actionMap = {\n      id: uuidv4(),\n      name: name ?? 'New Action Map',\n      tiles: [],\n      outputs: [],\n    };\n\n    return this.actionMap;\n  }\n\n  /**\n   * Renames the current ActionMap with a new specified name.\n   * This method updates the 'name' property of the ActionMap and then returns the updated ActionMap.\n   *\n   * @param {string} name - The new name to be assigned to the ActionMap.\n   * @returns {ActionMap} The updated ActionMap with the new name.\n   */\n  public renameActionMap(name: string): ActionMap {\n    this.actionMap.name = name;\n    return this.actionMap;\n  }\n\n  /**\n   * Validates the action map against a predefined schema.\n   *\n   * This function compiles and applies the action map schema using AJV to\n   * validate the current state of the action map. If the action map fails\n   * validation, an error is thrown detailing the validation issues.\n   *\n   * @returns {boolean} Returns true if the action map is valid according to\n   *           the schema.\n   * @throws {Error} Throws an error if the action map fails schema validation,\n   *         with details about the validation errors.\n   */\n  public validateSchema(): { isValid: boolean; errors: any[] } {\n    try {\n      actionMapSchema.validateSync(this.actionMap, {\n        abortEarly: false,\n      });\n\n      return {\n        isValid: true,\n        errors: [],\n      };\n    } catch (e: any) {\n      return {\n        isValid: false,\n        errors: e.errors,\n      };\n    }\n  }\n\n  /**\n   * Retrieves the output schema for an Accessor tile.\n   *\n   * This function determines the schema based on the source type of the Accessor\n   * tile, which is derived from its 'source' property. The source type can be\n   * Memory, Model, or Constant, each requiring different handling. It fetches\n   * the schema for Memory and Model types but throws an error for the Constant\n   * type and unrecognized source types.\n   *\n   * @param {AccessorTile} tile - The Accessor tile for which to find the output schema.\n   * @returns {Promise<DataSchema>} A promise that resolves to the data schema\n   *           associated with the Accessor tile's source.\n   * @throws {Error} Throws an error for the Constant source type or if the accessor\n   *         source type is invalid.\n   */\n  public getAccessorOutputSchema(\n    tile: AccessorTile,\n  ): DataSchema {\n    const source = tile.accessType;\n    const sourceType = source[0];\n    const sourceId = source[1];\n\n    switch (tile.accessType) {\n      case AccessorType.Memory:\n        return this.getMemorySchema(sourceId);\n      case AccessorType.Model: {\n        const modelSchema = this.getModelSchema(sourceId);\n\n        if ((tile as ModelAccessorTile).operation === ModelAccessOperation.FindMany) {\n          return {\n            type: ComplexDataType.Array,\n            arrayType: modelSchema,\n          };\n        }\n\n        return modelSchema;\n      }\n      case AccessorType.Constant:\n        throw new Error('No implementation');\n      case AccessorType.DataIn:\n        return (tile as DataInAccessorTile).dataInProps.type;\n      default:\n        throw new Error(`Invalid accessor source type: ${sourceType}`);\n    }\n  }\n\n  /**\n   * Validates a tile against its respective schema based on the tile type.\n   *\n   * This function determines the appropriate validation schema to use based on\n   * the tile's type (Accessor, Action, or Memory). It then compiles and applies\n   * this schema using AJV to validate the tile. If the tile type is invalid or\n   * the tile fails validation, an error is thrown.\n   *\n   * @param {Tile} tile - The tile object to be validated.\n   * @returns {boolean} Returns true if the tile is valid according to its schema.\n   * @throws {Error} Throws an error if the tile type is invalid or if the tile\n   *         fails schema validation.\n   */\n  public validateTile(tile: Tile): boolean {\n    if (this.tilesIntersect(tile.coordinates)) {\n      throw new Error('Tile has intersections');\n    }\n\n    switch (tile.type) {\n      case TileType.Accessor:\n        accessorTileSchema.validate(tile, {\n          abortEarly: false,\n        })\n        break;\n      case TileType.Action:\n        actionTileSchema.validate(tile, {\n          abortEarly: false,\n        });\n        break;\n      case TileType.Memory:\n        memoryTileSchema.validate(tile, {\n          abortEarly: false,\n        });\n        break;\n      default:\n        throw new Error(`Invalid tile type: ${tile.type}`);\n    }\n\n    return true;\n  }\n\n  /**\n   * Adds a new tile to the action map.\n   *\n   * This function first validates the provided tile using `validateTile`. If\n   * validation is successful, the tile is added to the action map's tiles array.\n   * The updated action map is then returned. It assumes that `validateTile`\n   * handles any necessary validation and throws errors if the tile is invalid.\n   *\n   * @param {Tile} tile - The tile object to be added to the action map.\n   * @returns {ActionMap} The updated action map with the new tile added.\n   */\n  public addTile(tile: Tile, actionSchemas?: ActionDataSchema): ActionMap {\n    this.validateTile(tile);\n\n    // check action schemas and cache them\n    if (tile.type === TileType.Action) {\n      if (!actionSchemas) {\n        throw new Error('Action schemas are not provided');\n      }\n\n      if ((tile as ActionTile).actionId !== actionSchemas.actionId) {\n        throw new Error('Action schemas are not for this action');\n      }\n\n      if (!this.usedActions.some((usedAction) => usedAction.actionId === actionSchemas.actionId)) {\n        this.usedActions.push(actionSchemas);\n      }\n    }\n\n    this.pushNewState({\n      ...this.actionMap,\n      tiles: [...this.actionMap.tiles, tile],\n    });\n\n    return this.actionMap;\n  }\n\n  /**\n   * Removes a tile from the action map and cleans up its associated inputs and outputs.\n   *\n   * This function locates a tile by its ID and removes it from the action map. It\n   * also identifies and deletes all inputs and outputs associated with this tile.\n   * If the tile is not found in the action map, it throws an error. The updated\n   * action map is then returned.\n   *\n   * @param {string} id - The unique identifier of the tile to be removed.\n   * @returns {ActionMap} The updated action map after the specified tile and its\n   *           associated inputs and outputs have been removed.\n   * @throws {Error} Throws an error if the tile with the specified ID is not found.\n   */\n  public removeTile(id: string): ActionMap {\n    const tile = this.actionMap.tiles.find((t: Tile) => t.id === id);\n\n    if (!tile) {\n      throw new Error(`Tile ${id} not found`);\n    }\n\n    // delete inputs ant outputs for this tile\n    const newOutputs = this.actionMap.outputs.filter((o) => o.outputTileId !== id && o.inputTileId !== id);\n\n    return this.pushNewState({\n      ...this.actionMap,\n      tiles: this.actionMap.tiles.filter((t) => t.id !== id),\n      outputs: newOutputs,\n    });\n  }\n\n  /**\n   * Asynchronously determines if two tiles can be connected.\n   *\n   * This function evaluates the possibility of connecting two tiles based on their\n   * types and data schemas. It supports Memory and Action tile types with specific\n   * compatibility rules. The function also utilizes a callback to return compatible\n   * paths found during the compatibility check. Returns true if the tiles can be\n   * connected, false otherwise.\n   *\n   * @param {string} fromTileId - The ID of the source tile.\n   * @param {string} toTileId - The ID of the destination tile.\n   * @param {(compatiblePaths: CompatiblePaths) => void} cb - A callback function\n   *        that receives compatible paths determined during the evaluation.\n   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating\n   *           whether the tiles can be connected.\n   */\n  public canConnectTiles(\n    fromTileId: string,\n    toTileId: string,\n    cb: (compatiblePaths: OutputCompatiblePaths) => void,\n  ): boolean {\n    const fromTile = this.actionMap.tiles.find(\n      (t: Tile) => t.id === fromTileId,\n    );\n    const toTile = this.actionMap.tiles.find((t: Tile) => t.id === toTileId);\n\n    let toSchema: DataSchema | null = null;\n\n    if (toTile?.type === TileType.Memory) {\n      toSchema = this.getMemorySchema(toTile.id);\n    }\n\n    if (toTile?.type === TileType.Action) {\n      toSchema = this.getActionArgumentsSchema(\n        (toTile as ActionTile).actionId,\n      );\n    }\n\n    if (!toSchema) {\n      return false;\n    }\n\n    const fromSchema = this.getTileOutputSchema(fromTile!);\n\n    return this.dataSchemaHandler.findCompatibilities(\n      fromSchema,\n      toSchema,\n      (source, target) => cb({\n        from: source,\n        to: target,\n      }),\n    );\n  }\n\n  /**\n   * Asynchronously adds a new output to the action map and updates related tiles.\n   *\n   * This function adds a new output with a generated ID to the action map. It\n   * ensures that the specified source and destination tiles exist and are\n   * compatible for the connection. The output is then linked to these tiles based\n   * on their types. Throws errors for non-existent tiles, incompatible tiles,\n   * and invalid tile types.\n   *\n   * @param {Omit<Output, 'id'>} output - The output to be added, excluding the 'id'.\n   * @param {string} fromTileId - The ID of the tile from which the output originates.\n   * @param {string} toTileId - The ID of the tile to which the output connects.\n   * @returns {Promise<ActionMap>} A promise that resolves to the updated action map\n   *           with the new output and updated tile connections.\n   * @throws {Error} Throws an error if source or destination tiles are not found,\n   *           if they are not compatible, or if their types are invalid for adding outputs.\n   */\n  public addOutput(\n    output: Omit<Output, 'id'>,\n  ): ActionMap {\n    // TODO: Add output validation\n\n    const fromTile = this.actionMap.tiles.find(\n      (t: Tile) => t.id === output.outputTileId,\n    );\n\n    if (!fromTile) {\n      throw new Error(`Tile ${output.outputTileId} not found`);\n    }\n\n    const toTile = this.actionMap.tiles.find((t: Tile) => t.id === output.inputTileId);\n\n    if (!toTile) {\n      throw new Error(`Tile ${output.inputTileId} not found`);\n    }\n\n    // TODO: enable this\n    let compatiblePaths: OutputCompatiblePaths;\n    // if (\n    //   !this.canConnectTiles(output.outputTileId, output.inputTileId, (paths) => {\n    //     compatiblePaths = paths;\n    //   })\n    // ) {\n    //   throw new Error(`Tiles ${output.outputTileId} and ${output.inputTileId} are not compatible`);\n    // }\n\n    // TODO: reimplement this\n    // if (!output.dataMap.every((dataMap) => compatiblePaths.some((path) => path.from === dataMap.outputPath && path.to === dataMap.inputPath))) {\n    //   throw new Error('Output data map is not compatible with tiles');\n    // }\n\n    const outputId = uuidv4();\n\n    this.pushNewState({\n      ...this.actionMap,\n      outputs: [\n        ...this.actionMap.outputs,\n        {\n          ...output,\n          id: outputId,\n        } as Output,\n      ],\n    });\n\n    this.actionMap.outputs.push({\n      ...output,\n      id: outputId,\n    } as Output);\n\n    return this.actionMap;\n  }\n\n  /**\n   * Removes an output from the action map and updates related tiles.\n   *\n   * This function first attempts to find and remove an output with the specified\n   * ID from the action map's outputs array. If the output is not found, it throws\n   * an error. It then updates all related tiles within the action map to remove\n   * any references to the deleted output. This includes updating input and output\n   * connections for tiles based on their type (Accessor, Action, Memory). Throws\n   * an error for unrecognized tile types.\n   *\n   * @param {string} id - The unique identifier of the output to be removed.\n   * @returns {ActionMap} The updated action map after removing the output and\n   *           updating related tiles.\n   * @throws {Error} Throws an error if the output with the specified ID is not found.\n   * @throws {Error} Throws an error if it encounters an invalid or unrecognized tile type.\n   */\n  // public removeOutput(id: string): ActionMap {\n  //   const index = this.actionMap.outputs.findIndex((o: Output) => o.id === id);\n\n  //   if (index === -1) {\n  //     throw new Error(`Output ${id} not found`);\n  //   }\n\n  //   this.actionMap.outputs.splice(index, 1);\n\n  //   // remove output from tiles\n  //   this.actionMap.tiles = this.actionMap.tiles.map((tile: Tile) => {\n  //     const tileCopy = { ...tile };\n\n  //     switch (tile.type) {\n  //       case TileType.Accessor:\n  //         (tileCopy as AccessorTile).output = (\n  //           tile as AccessorTile\n  //         ).output.filter((outputId: string) => outputId !== id);\n  //         break;\n  //       case TileType.Action:\n  //         (tileCopy as ActionTile).input = (tile as ActionTile).input.filter(\n  //           (outputId: string) => outputId !== id,\n  //         );\n  //         (tileCopy as ActionTile).output = (tile as ActionTile).output.filter(\n  //           (outputId: string) => outputId !== id,\n  //         );\n  //         break;\n  //       case TileType.Memory:\n  //         (tileCopy as MemoryTile).input = (tile as MemoryTile).input.filter(\n  //           (outputId: string) => outputId !== id,\n  //         );\n  //         break;\n  //       default:\n  //         throw new Error(`Invalid tile type: ${tile.type}`);\n  //     }\n\n  //     return tile;\n  //   });\n\n  //   return this.actionMap;\n  // }\n\n  /**\n   * Updates the coordinates of a specific tile in the action map.\n   *\n   * This function locates a tile by its ID within the action map. If found, \n   * it updates the tile's start and end coordinates. If the tile is not found, \n   * it throws an error. The updated action map is then returned.\n   *\n   * @param {string} id - The unique identifier of the tile to be updated.\n   * @param {[number, number]} start - The new starting coordinates of the tile.\n   * @param {[number, number]} end - The new ending coordinates of the tile.\n   * @returns {ActionMap} The updated action map containing the modified tile.\n   * @throws {Error} Throws an error if the tile with the specified ID is not found.\n   */\n  public updateTileCoordinates(\n    id: string,\n    position: [number, number],\n  ): ActionMap {\n    const tile = this.actionMap.tiles.find((t: Tile) => t.id === id);\n\n    if (!tile) {\n      throw new Error(`Tile ${id} not found`);\n    }\n\n    const anotherTileIntersects = this.tilesIntersect(position);\n\n    if (anotherTileIntersects) {\n      throw new Error('Tile intersects with another tile');\n    }\n\n    return this.pushNewState({\n      ...this.actionMap,\n      tiles: this.actionMap.tiles.map((t: Tile) => {\n        if (t.id === id) {\n          return {\n            ...t,\n            coordinates: position,\n          };\n        }\n\n        return t;\n      }),\n    });\n  }\n\n  /**\n   * Checks if a tile intersects with any other tile in the action map.\n   *\n   * This function checks if a tile with the specified start and end coordinates\n   * intersects with any other tile in the action map. If an intersection is found,\n   * it returns true. Otherwise, it returns false.\n   *\n   * @param {[number, number]} position - The coordinates of the tile to be checked.\n   * @returns {boolean} True if the tile intersects with another tile, false otherwise.\n   */\n  public tilesIntersect(position: [number, number]): boolean {\n    return Boolean(this.actionMap.tiles.find((t: Tile) => t.coordinates[0] === position[0] && t.coordinates[1] === position[1]));\n  }\n\n  /**\n   * Asynchronously retrieves the output schema for a given tile.\n   *\n   * Depending on the type of the tile, this function delegates to a specific\n   * method to fetch the corresponding schema. It supports different tile types\n   * such as Accessor, Action, and Memory. For unrecognized tile types, it throws\n   * an error.\n   *\n   * @param {Tile} tile - The tile for which to find the output schema.\n   * @returns {Promise<DataSchema>} A promise that resolves to the data schema\n   *           associated with the tile's output. The specific schema returned\n   *           depends on the tile type.\n   * @throws {Error} Throws an error if the tile type is invalid or unrecognized.\n   */\n  public getTileOutputSchema(tile: Tile): DataSchema {\n    switch (tile.type) {\n      case TileType.Accessor:\n        return this.getAccessorOutputSchema(tile as AccessorTile);\n      case TileType.Action:\n        return this.getActionOutputSchema((tile as ActionTile).actionId);\n      case TileType.Memory:\n        return this.getMemorySchema(tile.id);\n      default:\n        throw new Error(`Invalid tile type: ${tile.type}`);\n    }\n  }\n\n  /**\n   * Asynchronously retrieves the schema for the arguments of a specified action.\n   *\n   * This function fetches the details of the action based on the given action ID.\n   * If the action is found, it parses the arguments of the action into a data\n   * schema format. If the action is not found, it throws an error.\n   *\n   * @param {string} actionId - The unique identifier of the action.\n   * @returns {Promise<DataSchema>} A promise that resolves to the data schema of\n   *           the action's arguments. The schema is parsed from a JSON string.\n   * @throws {Error} Throws an error if the action is not found.\n   */\n  public getActionArgumentsSchema(actionId: string): DataSchema {\n    const action = this.usedActions.find((a) => a.actionId === actionId);\n\n    if (!action) {\n      throw new Error(`Action ${actionId} not found`);\n    }\n\n    return action.arguments;\n  }\n\n  public undo(): ActionMap {\n    return this.returnToPreviousState();\n  }\n\n  public redo(): ActionMap {\n    return this.returnToFutureState();\n  }\n\n  public getTileOutputs(tileId: string): Output[] {\n    return this.actionMap.outputs.filter((o) => o.outputTileId === tileId);\n  }\n\n  public getTileInputs(tileId: string): Output[] {\n    return this.actionMap.outputs.filter((o) => o.inputTileId === tileId);\n  }\n\n  // PROTECTED -----------------------------------------------------------------\n  protected getMemoryInitialSchema(tileId: string): DataSchema {\n    const memory = this.getMemoryById(tileId);\n\n    if (!memory) {\n      throw new Error(`Memory ${tileId} not found`);\n    }\n\n    if (memory.memoryType === MemoryType.Model) {\n      return this.getModelSchema((memory as ModelMemoryTile).modelName);\n    }\n\n    const initialMemorySchema: DataSchema = {\n      type: ComplexDataType.Object,\n      properties: (memory as InternalMemoryTile).properties.reduce((acc, prop) => {\n        acc[prop] = {\n          type: SpecialDataType.Any,\n          required: true,\n        };\n\n        return acc;\n      }, {}),\n      required: true,\n    }\n\n    return initialMemorySchema;\n  }\n\n  protected pushNewState(actionMap: ActionMap): ActionMap {\n    this.clearFutureStack();\n\n    this.changeStack.push(this.actionMap);\n    if (this.changeStack.length > 10) {\n      this.changeStack.shift();\n    }\n\n    this.actionMap = actionMap;\n\n    return actionMap;\n  }\n\n  protected returnToPreviousState(): ActionMap {\n    this.putCurrentToFutureState();\n\n    this.actionMap = this.changeStack.pop() ?? this.actionMap;\n\n    return this.actionMap;\n  }\n\n  protected putCurrentToFutureState(): ActionMap {\n    if (!this.actionMap) {\n      return this.actionMap;\n    }\n\n    this.futureStack.push(this.actionMap);\n    if (this.futureStack.length > 10) {\n      this.futureStack.shift();\n    }\n\n    return this.actionMap;\n  }\n\n  protected putCurrentToPreviousState(): ActionMap {\n    if (!this.actionMap) {\n      return this.actionMap;\n    }\n\n    this.changeStack.push(this.actionMap);\n    if (this.changeStack.length > 10) {\n      this.changeStack.shift();\n    }\n\n    return this.actionMap;\n  }\n\n  protected clearFutureStack(): ActionMap {\n    this.futureStack = [];\n    return this.actionMap;\n  }\n\n  protected returnToFutureState(): ActionMap {\n    this.putCurrentToPreviousState();\n\n    this.actionMap = this.futureStack.pop() ?? this.actionMap;\n\n    return this.actionMap;\n  }\n\n  protected getActionOutputSchema(actionId: string): DataSchema {\n    const action = this.usedActions.find((a) => a.actionId === actionId);\n\n    if (!action) {\n      throw new Error(`Action ${actionId} not found`);\n    }\n\n    return action.output;\n  }\n\n  protected getModelSchema(modelName: string): DataSchema {\n    const model = this.models.find((m: Model) => m.name === modelName);\n\n    if (!model) {\n      throw new Error(`Model ${modelName} not found`);\n    }\n\n    return JSON.parse(model.schema) as DataSchema;\n  }\n\n  protected getMemoryById(id: string): MemoryTile | null {\n    return (this.actionMap.tiles.find(\n      (tile: Tile) => tile.type === TileType.Memory && tile.id === id,\n    ) || null) as MemoryTile | null;\n  }\n\n  protected getMemorySchema(id: string): DataSchema {\n    // Retrieve a memory object by its ID. Throws an error if not found.\n    const memory = this.getMemoryById(id);\n    if (!memory) {\n      throw new Error(`Memory ${id} not found`);\n    }\n\n    // Fetch the outputs associated with the memory's input IDs.\n    const inOutputs = this.getOutputsByOutputTileId(memory.id);\n\n    return this.outputsToDataSchema(inOutputs);\n  }\n\n  /**\n   * Asynchronously processes a list of outputs and retrieves their corresponding data schemas.\n   * This method maps each output to its source tile and extracts the relevant schema.\n   * It also performs validation on the schemas and extracts sub-schemas\n   * based on specified output paths.\n   *\n   * @param {Output[]} inOutputs - An array of outputs to be processed.\n   * @returns {Promise<{argument?: string; schema: DataSchema}[]>} A promise that resolves\n   * to an array of objects,\n   * each containing an optional argument string and a data schema. The 'argument' corresponds\n   * to the 'toArgument' property of the output,\n   * and 'schema' is the resolved data schema for that output.\n   *\n   * @throws {Error} If the schema from the source tile is invalid or if the specified outputPath\n   * does not exist in the tile's schema.\n   *\n   * Each output is processed as follows:\n   * 1. For each output, its source tile is identified.\n   * 2. The schema associated with the source tile's output is retrieved.\n   * 3. If an outputPath is specified for the output, the schema for that specific path\n   * is extracted and validated.\n   *    If the outputPath is not valid, an error is thrown.\n   * 4. If no outputPath is specified, the entire schema from the source tile is used.\n   * 5. The resulting schema and any argument are added to the return array.\n   */\n  protected outputsToDataSchema(\n    inOutputs: Output[],\n  ): DataSchema {\n    const dataSchema = {\n      type: ComplexDataType.Object,\n      properties: {},\n      required: true,\n    };\n\n    inOutputs.forEach((output: Output) => {\n      const sourceTile = this.getSourceTileForOutput(output.id);\n\n      const sourceTileOutputSchema = this.getTileOutputSchema(sourceTile);\n\n      output.dataMap.forEach((dataMap) => {\n        const outputSchema = this.dataSchemaHandler.getSchemaFromPath(\n          sourceTileOutputSchema,\n          dataMap.outputPath,\n        );\n\n        if (!this.dataSchemaHandler.validateSchema(outputSchema)) {\n          throw new Error(\n            `Output field ${dataMap.outputPath} not found in tile ${sourceTile.id}`,\n          );\n        }\n\n        dataSchema.properties![dataMap.inputPath] = outputSchema;\n      });\n    });\n\n    return dataSchema;\n  }\n\n  protected getOutputById(id: string): Output {\n    const output = this.actionMap.outputs.find((o: Output) => o.id === id);\n\n    if (!output) {\n      throw new Error(`Output ${id} not found`);\n    }\n\n    return output;\n  }\n\n  protected getOutputsByIds(ids: string[]): Output[] {\n    return this.actionMap.outputs.filter((o: Output) => ids.includes(o.id));\n  }\n\n  protected getOutputsByOutputTileId(id: string): Output[] {\n    return this.actionMap.outputs.filter((o: Output) => o.outputTileId === id);\n  }\n\n  protected getSourceTileForOutput(outputId: string): Tile {\n    const output = this.actionMap.outputs.find((o: Output) => o.id === outputId);\n    if (!output) {\n      throw new Error(`Output ${outputId} not found`);\n    }\n\n    const tile = this.actionMap.tiles.find((t: Tile) => t.id === output?.outputTileId);\n    if (!tile) {\n      throw new Error(`Tile for output ${outputId} not found`);\n    }\n\n    return tile;\n  }\n}\n","import { DataSchema, DataSchemaWithCompatibility } from '../../dataSchema/types/dataSchema';\n\n// Data access types -----------------------------------------------------------\nexport enum SourceType {\n  Constant = 'constant',\n  Memory = 'memory',\n  Model = 'model',\n  Input = 'input',\n}\n\nexport type DataSource = {\n  type: SourceType;\n  name: string;\n};\n\n// Condition operators ---------------------------------------------------------\nexport enum ConditionOperator {\n  Equal = '==',\n  StrongEqual = '===',\n  NotEqual = '!=',\n  StrongNotEqual = '!==',\n  GreaterThan = '>',\n  GreaterThanOrEqual = '>=',\n  LessThan = '<',\n  LessThanOrEqual = '<=',\n  Not = '!',\n}\n\nexport enum LogicalOperator {\n  And = '&&',\n  Or = '||',\n}\n\nexport type Condition = {\n  operator: ConditionOperator;\n  leftValue: DataSource | Condition;\n  rightValue?: DataSource | Condition;\n};\n\n// Output types ----------------------------------------------------------------\nexport enum OutputType {\n  Default = 'default',\n  Conditional = 'conditional',\n  ForEach = 'forEach',\n}\n\nexport type OutputCompatiblePaths = {\n  from: DataSchemaWithCompatibility;\n  to: DataSchemaWithCompatibility;\n};\n\nexport type ConnectionDataMap = {\n  outputPath: string;\n  inputPath: string;\n};\n\nexport type OutputGeneral = {\n  id: string;\n  type: OutputType;\n  outputTileId: Tile['id'];\n  inputTileId: Tile['id'];\n  dataMap: ConnectionDataMap[];\n};\n\nexport type DefaultOutput = OutputGeneral & {\n  type: OutputType.Default;\n};\n\nexport type ConditionalOutput = OutputGeneral & {\n  type: OutputType.Conditional;\n  condition: Condition;\n};\n\nexport type ForEachOutput = OutputGeneral & {\n  type: OutputType.ForEach;\n  forEachDataMap: ConnectionDataMap;\n};\n\nexport type Output = DefaultOutput | ConditionalOutput | ForEachOutput;\n\n// Tile types ------------------------------------------------------------------\nexport enum TileType {\n  Accessor = 'accessor',\n  Action = 'action',\n  Memory = 'memory',\n}\n\nexport type TileGeneral = {\n  id: string;\n  coordinates: [number, number];\n  type: TileType;\n};\n\nexport enum AccessorType {\n  Model = 'model',\n  Constant = 'constant',\n  Memory = 'memory',\n  DataIn = 'dataIn',\n}\n\nexport type AccessorTile = TileGeneral & {\n  accessType: AccessorType;\n};\n\nexport type ConstantAccessorTile = AccessorTile & {\n  accessType: AccessorType.Constant;\n  constantName: string;\n};\n\nexport type DataInAccessorTile = AccessorTile & {\n  accessType: AccessorType.DataIn;\n  dataInProps: DataIn;\n};\n\nexport type MemoryAccessorTile = AccessorTile & {\n  accessType: AccessorType.Memory;\n  memoryTileId: string;\n};\n\nexport enum  ModelAccessOperation {\n  FindOne = 'findOne',\n  FindMany = 'findMany',\n  FindFirst = 'findFirst',\n  FindLast = 'findLast',\n};\n\nexport type ModelAccessorTile = AccessorTile & {\n  accessType: AccessorType.Model;\n  modelName: string;\n  query: string; // TODO: delete?\n  operation: ModelAccessOperation;\n};\n\nexport type ActionTile = TileGeneral & {\n  actionId: string;\n};\n\nexport enum MemoryType {\n  DataOut = 'dataOut',\n  Internal = 'internal',\n  Model = 'model',\n}\n\nexport type MemoryTile = TileGeneral & {\n  memoryType: MemoryType;\n};\n\nexport enum ModelMemoryOperation {\n  Create = 'create',\n  Update = 'update',\n  Delete = 'delete',\n};\n\nexport type ModelMemoryTile = MemoryTile & {\n  memoryType: MemoryType.Model;\n  modelName: string;\n  query: string; // TODO: delete?\n  operation: ModelMemoryOperation;\n};\n\nexport type DataOutMemoryTile = MemoryTile & {\n  memoryType: MemoryType.DataOut;\n  memoryName: string;\n  properties: string[];\n};\n\nexport type InternalMemoryTile = MemoryTile & {\n  memoryType: MemoryType.Internal;\n  memoryName: string;\n  properties: string[];\n};\n\nexport type Tile = AccessorTile\n| ActionTile\n| MemoryTile\n| ModelMemoryTile\n| ModelAccessorTile\n| ConstantAccessorTile\n| DataInAccessorTile\n| MemoryAccessorTile;\n\n// Action data schemas ---------------------------------------------------------\nexport type ActionDataSchema = {\n  actionId: string;\n  arguments: DataSchema;\n  output: DataSchema;\n};\n\n// Data in types ---------------------------------------------------------------\nexport type DataIn = {\n  name: string;\n  label: string;\n  type: DataSchema;\n  required: boolean;\n  defaultValue?: any;\n};\n\n// Action map types ------------------------------------------------------------\nexport type ActionMap = {\n  id: string;\n  name: string;\n  outputs: Output[];\n  tiles: Tile[];\n};\n","import * as yup from 'yup';\nimport outputSchema from './output.schema';\nimport tileSchema from './tile.schema';\n\n// ActionMap schema\nconst actionMapSchema = yup.object().shape({\n  id: yup.string().required(),\n  name: yup.string().required(),\n  outputs: yup.array().of(outputSchema).required(),\n  tiles: yup.array().of(tileSchema).required(),\n});\n\nexport default actionMapSchema;\n","import * as yup from 'yup';\nimport { OutputType } from '../types/actionMap';\n\n// OutputDirection schema\n// const outputDirectionSchema = yup\n//   .mixed<OutputDirection>()\n//   .oneOf(Object.values(OutputDirection));\n\n// OutputType schema\nconst outputTypeSchema = yup\n  .mixed<OutputType>()\n  .oneOf(Object.values(OutputType));\n\n// Base OutputGeneral schema\nconst outputGeneralSchema = yup.object().shape({\n  id: yup.string().required(),\n  // direction: outputDirectionSchema.required(),\n  // coordinates: yup\n  //   .array()\n  //   .of(yup.number())\n  //   .min(2)\n  //   .max(2)\n  //   .required(),\n  toArgument: yup.string().nullable(),\n  type: outputTypeSchema.required(),\n  outputPath: yup.string().nullable(),\n});\n\n// DefaultOutput schema\nconst defaultOutputSchema = outputGeneralSchema\n  .concat(yup.object({\n    type: yup.mixed().oneOf([OutputType.Default]),\n  }));\n\n// ConditionalOutput schema\nconst conditionalOutputSchema = outputGeneralSchema\n  .concat(yup.object({\n    type: yup.mixed().oneOf([OutputType.Conditional]),\n    condition: yup.string().required(),\n  }));\n\n// ForEachOutput schema\nconst forEachOutputSchema = outputGeneralSchema\n  .concat(yup.object({\n    type: yup.mixed().oneOf([OutputType.ForEach]),\n  }));\n\n// Combined Output schema\nconst outputSchema = yup.lazy(value => {\n  switch (value.type) {\n    case OutputType.Default:\n      return defaultOutputSchema;\n    case OutputType.Conditional:\n      return conditionalOutputSchema;\n    case OutputType.ForEach:\n      return forEachOutputSchema;\n    default:\n      return yup.object().shape({});\n  }\n});\n\nexport default outputSchema;\n","import * as yup from 'yup';\nimport { AccessorType, MemoryType, ModelAccessOperation, ModelMemoryOperation, TileType } from '../types/actionMap';\nimport dataSchemaSchema from '../../dataSchema/schema/dataSchema.schema';\n\nexport const dataInSchema = yup.object().shape({\n  name: yup.string().required(),\n  label: yup.string().required(),\n  type: dataSchemaSchema.required(),\n  required: yup.boolean().required(),\n  defaultValue: yup.mixed().nullable(),\n});\n\n// TileType schema\nexport const tileTypeSchema = yup\n  .mixed<TileType>()\n  .oneOf(Object.values(TileType));\n\n// AccessorType schema\nexport const accessorTypeSchema = yup\n  .mixed<AccessorType>()\n  .oneOf(Object.values(AccessorType));\n\n// ModelAccessOperation schema\nexport const modelAccessOperationSchema = yup\n  .mixed<ModelAccessOperation>()\n  .oneOf(Object.values(ModelAccessOperation));\n\n// ModelMemoryOperation schema\nexport const modelMemoryOperationSchema = yup\n  .mixed<ModelMemoryOperation>()\n  .oneOf(Object.values(ModelMemoryOperation));\n\n// Base TileGeneral schema\nexport const tileGeneralSchema = yup.object().shape({\n  id: yup.string().required(),\n  coordinates: yup.array().of(yup.number()).min(2).max(2).required(),\n  type: tileTypeSchema.required(),\n});\n\n// AccessorTile schema\nexport const accessorTileSchema = tileGeneralSchema\n  .concat(yup.object({\n    accessType: accessorTypeSchema.required(),\n  }));\n\n// ConstantAccessorTile schema\nexport const constantAccessorTileSchema = accessorTileSchema\n  .concat(yup.object({\n    accessType: yup.mixed().oneOf([AccessorType.Constant]),\n    constantName: yup.string().required(),\n  }));\n\n// DataInAccessorTile schema\nexport const dataInAccessorTileSchema = accessorTileSchema\n  .concat(yup.object({\n    accessType: yup.mixed().oneOf([AccessorType.DataIn]),\n    dataInProps: dataInSchema.required(),\n  }));\n\n// MemoryAccessorTile schema\nexport const memoryAccessorTileSchema = accessorTileSchema\n  .concat(yup.object({\n    accessType: yup.mixed().oneOf([AccessorType.Memory]),\n    memoryTileId: yup.string().required(),\n  }));\n\n// ModelAccessorTile schema\nexport const modelAccessorTileSchema = accessorTileSchema\n  .concat(yup.object({\n    accessType: yup.mixed().oneOf([AccessorType.Model]),\n    modelName: yup.string().required(),\n    // query: yup.string().required(),\n    operation: modelAccessOperationSchema.required(),\n  }));\n\n// ActionTile schema\nexport const actionTileSchema = tileGeneralSchema\n  .concat(yup.object({\n    output: yup.array().of(yup.string()).required(),\n    actionId: yup.string().required(),\n    input: yup.array().of(yup.string()).required(),\n  }));\n\n// MemoryTile schema\nexport const memoryTileSchema = tileGeneralSchema\n  .concat(yup.object({\n    memoryType: yup\n      .mixed<MemoryType>()\n      .oneOf(Object.values(MemoryType))\n      .required(),\n  }));\n\n// ModelMemoryTile schema\nexport const modelMemoryTileSchema = memoryTileSchema\n  .concat(yup.object({\n    memoryType: yup.mixed().oneOf([MemoryType.Model]),\n    modelName: yup.string().required(),\n    // query: yup.string().required(),\n    operation: modelMemoryOperationSchema.required(),\n  }));\n\n// Combined Tile schema\nconst tileSchema = yup.lazy(value => {\n  switch (value.type) {\n    case TileType.Accessor:\n      switch (value.accessType) {\n        case AccessorType.Constant:\n          return constantAccessorTileSchema;\n        case AccessorType.DataIn:\n          return dataInAccessorTileSchema;\n        case AccessorType.Memory:\n          return memoryAccessorTileSchema;\n        case AccessorType.Model:\n          return modelAccessorTileSchema;\n        default:\n          return accessorTileSchema;\n      }\n    case TileType.Action:\n      return actionTileSchema;\n    case TileType.Memory:\n      return (value.memoryType === MemoryType.Model) ? modelMemoryTileSchema : memoryTileSchema;\n    default:\n      return yup.object().shape({\n        type: yup.mixed<TileType>().oneOf(Object.values(TileType)).required(),\n      });\n  }\n});\n\nexport default tileSchema;\n","import * as yup from 'yup';\nimport { ComplexDataType, ContentDataType, FormatDataType, SimpleDataType } from '../types/dataSchema';\n\n// SimpleDataType, FormatDataType, ContentDataType, ComplexDataType enums\nconst simpleDataTypeSchema = yup.mixed<SimpleDataType>().oneOf(Object.values(SimpleDataType));\nconst formatDataTypeSchema = yup.mixed<FormatDataType>().oneOf(Object.values(FormatDataType));\nconst contentDataTypeSchema = yup.mixed<ContentDataType>().oneOf(Object.values(ContentDataType));\nconst complexDataTypeSchema = yup.mixed<ComplexDataType>().oneOf(Object.values(ComplexDataType));\n\n// DataTypes schema\nconst dataTypesSchema = yup.lazy(value => \n  yup.array().of(\n    yup.mixed().oneOf([\n      simpleDataTypeSchema, \n      formatDataTypeSchema, \n      contentDataTypeSchema, \n      complexDataTypeSchema\n    ])\n  ).required()\n);\n\n// Recursive DataSchema schema\nconst dataSchema = yup.object({\n  type: dataTypesSchema,\n  properties: yup.lazy((value) => \n    yup.object().shape(\n      Object.keys(value).reduce((shape, key) => {\n        shape[key] = dataSchema;\n        return shape;\n      }, {})\n    ).nullable()\n  ),\n  arrayType: yup.lazy(() => dataSchema.nullable()),\n  description: yup.string().nullable(),\n  defaultValue: yup.mixed().nullable(),\n  required: yup.boolean().nullable(),\n});\n\nexport default dataSchema;\n","import { cloneDeep } from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  ComplexDataType,\n  DataSchema,\n  SimpleDataType,\n  DataTypes,\n  ContentDataType,\n  SchemasCompatibilityTypes,\n  DataSchemaWithCompatibility,\n  CompatibilitySide,\n  SpecialDataType,\n} from './types/dataSchema';\nimport pathValidateAndFormat from '../actionMap/helpers/pathValidateAndFormat';\n\n// type PropertyItem = {\n//   name: string;\n//   type: DataTypes | DataTypes[];\n//   children?: PropertyItem[];\n// };\n\n// type PropertyTree = PropertyItem[];\n\n// export type CompatiblePaths = { from: string; to: string, compatibilityType: SchemasCompatibilityTypes }[];\n\nexport class DataSchemaHandler {\n  // public getPropertiesTree(schema: DataSchema): PropertyTree {\n  //   return this.getPropertiesTreeFromSchema(schema);\n  // }\n\n  public isSchemasCompatible(schema: DataSchema, schemaToCompare: DataSchema): boolean {\n    return this.isSchemasCompatibleRecursive(schema, schemaToCompare);\n  }\n\n  public findCompatibilities(\n    source: DataSchema,\n    target: DataSchema,\n    cb: (source: DataSchemaWithCompatibility, target: DataSchemaWithCompatibility) => void,\n  ): boolean {\n    if (!this.validateSchema(source) || !this.validateSchema(target)) {\n      throw new Error('Invalid schemas');\n    }\n\n    const someCompatible = false;\n\n    const sourceC = cloneDeep(source) as DataSchemaWithCompatibility;\n    const targetC = cloneDeep(target) as DataSchemaWithCompatibility;\n\n    const sourceDataSchemas: DataSchemaWithCompatibility[] = [];\n    const targetDataSchemas: DataSchemaWithCompatibility[] = Object.values(targetC.properties || {});\n\n    this.walkThroughPropertiesRecursive(sourceC, (partialSchema) => {\n      sourceDataSchemas.push(partialSchema);\n    });\n\n    for (const sourceSchema of sourceDataSchemas) {\n      for (const targetSchema of targetDataSchemas) {\n        if (this.isSchemasCompatibleRecursive({ ...sourceSchema, required: true }, targetSchema)) {\n          sourceSchema.compatibility = sourceSchema.compatibility || [];\n          targetSchema.compatibility = targetSchema.compatibility || [];\n\n          const uuid = uuidv4();\n          const type = !sourceSchema.required && targetSchema.required\n            ? SchemasCompatibilityTypes.Conditional\n            : SchemasCompatibilityTypes.Direct;\n\n          sourceSchema.compatibility.push({\n            id: uuid,\n            side: CompatibilitySide.Source,\n            type,\n          });\n          targetSchema.compatibility.push({\n            id: uuid,\n            side: CompatibilitySide.Target,\n            type,\n          });\n        }\n\n        if (\n          sourceSchema.type === ComplexDataType.Array\n          && this.isSchemasCompatibleRecursive(sourceSchema.arrayType!, targetSchema)\n        ) {\n          sourceSchema.compatibility = sourceSchema.compatibility || [];\n          targetSchema.compatibility = targetSchema.compatibility || [];\n\n          const uuid = uuidv4();\n\n          sourceSchema.compatibility.push({\n            id: uuid,\n            side: CompatibilitySide.Source,\n            type: SchemasCompatibilityTypes.ArrayItem,\n          });\n          targetSchema.compatibility.push({\n            id: uuid,\n            side: CompatibilitySide.Target,\n            type: SchemasCompatibilityTypes.ArrayItem,\n          });\n        }\n      }\n    }\n\n    return someCompatible;\n  }\n\n  // public isSchemaPartiallyCompatible(\n  //   schemaFrom: DataSchema,\n  //   schemaTo: DataSchema,\n  //   cb: (compatiblePaths: string[]) => any,\n  // ): boolean {\n  //   const compatiblePaths: string[] = [];\n\n  //   this.walkThroughPropertiesRecursive(schemaFrom, (partialSchema, path) => {\n  //     if (this.isSchemasCompatibleRecursive(partialSchema, schemaTo)) {\n  //       compatiblePaths.push(path);\n  //     }\n  //   });\n\n  //   cb(compatiblePaths);\n\n  //   return compatiblePaths.length > 0;\n  // }\n\n  // public isPartiallyCompatible(\n  //   schemaFrom: DataSchema,\n  //   schemaTo: DataSchema,\n  //   cb: (compatiblePaths: CompatiblePaths) => any,\n  // ): boolean {\n  //   const compatiblePaths: CompatiblePaths = [];\n\n  //   Object.entries(schemaTo.properties || {}).forEach(([key, destProperty]) => {\n  //     this.walkThroughPropertiesRecursive(schemaFrom, (partialSchema, path) => {\n  //       if (this.isSchemasCompatibleRecursive(partialSchema, destProperty)) {\n  //         compatiblePaths.push({ from: path, to: key, compatibilityType: SchemasCompatibilityTypes.Direct });\n  //       }\n\n  //       if (\n  //         !partialSchema.required\n  //           && destProperty.required\n  //           && this.isSchemasCompatibleRecursive({ ...partialSchema, required: true }, destProperty)\n  //       ) {\n  //         compatiblePaths.push({ from: path, to: key, compatibilityType: SchemasCompatibilityTypes.Conditional });\n  //       }\n\n  //       if (\n  //         partialSchema.type === ComplexDataType.Array\n  //           && this.isSchemasCompatibleRecursive(partialSchema.arrayType!, destProperty)\n  //       ) {\n  //         compatiblePaths.push({\n  //           from: path,\n  //           to: key,\n  //           compatibilityType: SchemasCompatibilityTypes.ForEach,\n  //         });\n  //       }\n  //     });\n  //   });\n\n  //   cb(compatiblePaths);\n\n  //   return compatiblePaths.length > 0;\n  // }\n\n  public validateSchema(schema: DataSchema): boolean {\n    if (schema.type !== ComplexDataType.Object && schema.properties) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public walkThroughPropertiesRecursive(\n    schema: DataSchema,\n    callback: (partialSchema: DataSchema) => void,\n  ) {\n    switch (schema.type) {\n      case SimpleDataType.Text:\n      case SimpleDataType.Number:\n      case SimpleDataType.Date:\n      case SimpleDataType.YesNo:\n      case ContentDataType.File:\n      case ContentDataType.Image:\n      case ContentDataType.Video:\n      case ContentDataType.Audio:\n      case SpecialDataType.Any:\n        callback(schema);\n        break;\n      case ComplexDataType.Object:\n        Object.entries(schema.properties || {}).forEach(\n          ([key, value]: [string, DataSchema]) => {\n            this.walkThroughPropertiesRecursive(\n              value,\n              (partialSchema) => {\n                callback(partialSchema);\n              },\n            );\n          },\n        );\n        break;\n      case ComplexDataType.Array:\n        this.walkThroughPropertiesRecursive(\n          schema.arrayType!,\n          (dSchema) => {\n            callback(dSchema);\n          },\n        );\n        break;\n      default:\n        throw new Error(`Unsupported data type: ${schema.type}`);\n    }\n  }\n\n  public getSchemaFromPath(schema: DataSchema, path: string): DataSchema {\n    const pathParts = pathValidateAndFormat(path)\n      .replace(/[\\[\\]\\d]/g, \"\")\n      .split(\".\")\n      .filter((part) => part !== '');\n\n    let currentSchema = schema;\n\n    for (const pathPart of pathParts) {\n      switch (currentSchema.type) {\n        case ComplexDataType.Object:\n          currentSchema = currentSchema.properties![pathPart];\n          break;\n        case ComplexDataType.Array:\n          currentSchema = currentSchema.arrayType!;\n          break;\n        default:\n          throw new Error(\n            `Unsupported data type: ${currentSchema.type} at path: ${path}`,\n          );\n      }\n    }\n\n    return currentSchema;\n  }\n\n  private isSchemasCompatibleRecursive(\n    schemaFrom: DataSchema,\n    schemaTo: DataSchema,\n  ): boolean {\n    if (schemaFrom.type !== schemaTo.type) {\n      return false;\n    }\n\n    switch (schemaFrom.type) {\n      case SimpleDataType.Text:\n      case SimpleDataType.Number:\n      case SimpleDataType.Date:\n      case SimpleDataType.YesNo:\n      case ContentDataType.File:\n      case ContentDataType.Image:\n      case ContentDataType.Video:\n      case ContentDataType.Audio:\n        return schemaFrom.required === schemaTo.required || !schemaTo.required;\n      case ComplexDataType.Object:\n        return Object.entries(schemaFrom.properties || {}).every(\n          ([key, value]) => {\n            const schemaToProperty = schemaTo.properties?.[key];\n            if (!schemaToProperty) {\n              return false;\n            }\n            return this.isSchemasCompatibleRecursive(value, schemaToProperty);\n          },\n        );\n      case ComplexDataType.Array:\n        return this.isSchemasCompatibleRecursive(\n          schemaFrom.arrayType!,\n          schemaTo.arrayType!,\n        );\n      default:\n        throw new Error(`Unsupported data type: ${schemaFrom.type}`);\n    }\n  }\n\n  // private getPropertiesTreeFromSchema(schema: DataSchema): PropertyTree {\n  //   switch (schema.type) {\n  //     case SimpleDataType.Text:\n  //     case SimpleDataType.Number:\n  //     case SimpleDataType.Date:\n  //     case SimpleDataType.YesNo:\n  //       return [];\n  //     case ComplexDataType.Array:\n  //       return this.getPropertiesTreeFromSchema(schema.arrayType!);\n  //     case ComplexDataType.Object:\n  //       return Object.entries(schema.properties || {}).map(\n  //         ([key, value]: [string, DataSchema]) => ({\n  //           name: key,\n  //           type: value.type,\n  //           children: this.getPropertiesTreeFromSchema(value),\n  //         }),\n  //       );\n  //     default:\n  //       throw new Error(`Unsupported data type: ${schema.type}`);\n  //   }\n  // }\n}\n","const pathValidateAndFormat = (path?: string, chainLength?: number): string => {\n  if (!path) {\n    return '';\n  }\n\n  const symbols = path.match(/[^\\.a-zA-Z0-9\\[\\]]/g);\n  if (symbols) {\n    throw new Error(`Invalid symbols in path: ${path}`);\n  }\n\n  if (path[0] === '.') {\n    return path.slice(1);\n  }\n\n  if (chainLength && path.split('.').length !== chainLength) {\n    throw new Error(`Invalid path length: ${path}`);\n  }\n\n  return path;\n}\n\nexport default pathValidateAndFormat;\n"],"names":[],"version":3,"file":"module.js.map"}